<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 2 页 | you left，I right</title>
  <meta name="author" content="happy1st">
  
  <meta name="description" content="记录后青春">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="you left，I right"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="alternate" href="/atom.xml" title="you left，I right" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

  <script src="https://cdn1.lncld.net/static/js/3.6.1/av-min.js"></script>
  <script>
	var APP_ID = 'rhvUkXBxc7IAl5eYvkEV4kCy-gzGzoHsz';
	var APP_KEY = 'M26DgAo4H6hhYGjL4ILzR9ap';

	AV.init({
  		appId: APP_ID,
  		appKey: APP_KEY
	});
</script>
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">you left，I right</a></h1>
  <h2><a href="/"></a></h2>
  <div><a href="/">Heroes come and go , but legends are forever !</a></div>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-07-30T03:02:35.814Z"><a href="/2018/07/30/数据存储/Redis/">2018-07-30</a></time>
      
      
  
    <h1 class="title"><a href="/2018/07/30/数据存储/Redis/"></a></h1>
  

    </header>
    <div class="entry">
      
        <p>Redis 是一个使用 C 语言写成的，开源的 key-value 数据库。。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。目前，Vmware在资助着redis项目的开发和维护。</p>
<blockquote>
<h3 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h3></blockquote>
<p><strong>《Redis实战》</strong></p>
<p><strong>《Redis设计与实现》</strong></p>
<blockquote>
<h3 id="教程推荐"><a href="#教程推荐" class="headerlink" title="教程推荐"></a>教程推荐</h3></blockquote>
<p><strong>redis官方中文版教程</strong>：<a href="http://www.redis.net.cn/tutorial/3501.html" target="_blank" rel="noopener">http://www.redis.net.cn/tutorial/3501.html</a></p>
<p><strong>Redis 教程（菜鸟教程）</strong>：<a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/redis/redis-tutorial.html</a></p>
<blockquote>
<h3 id="常见问题总结"><a href="#常见问题总结" class="headerlink" title="常见问题总结"></a>常见问题总结</h3></blockquote>
<p><strong>学完Redis之后要问自己下面几个问题：</strong></p>
<ul>
<li>Redis的两种持久化操作以及如何保障数据安全（快照和AOF），</li>
<li>如何防止数据出错（Redis事务），</li>
<li>如何使用流水线来提升性能，</li>
<li>Redis主从复制，</li>
<li>Redis集群的搭建</li>
<li>Redis的几种淘汰策略</li>
</ul>
<p><strong>《一文轻松搞懂redis集群原理及搭建与使用》：</strong><br><a href="https://juejin.im/post/5ad54d76f265da23970759d3" target="_blank" rel="noopener">https://juejin.im/post/5ad54d76f265da23970759d3</a></p>
<p>昨天写了一篇自己搭建redis集群并在自己项目中使用的文章，今天早上看别人写的面经发现redis在面试中还是比较常问的（笔主主Java方向）。所以查阅官方文档以及他人造好的轮子，总结了一些redis面试和学习中你必须掌握的问题。事无巨细，不可能囊括到所有内容，尽量把比较常见的写出来。欢迎关注我的微信公众号：“<strong>Java面试通关手册</strong>”，也可以加我微信：“<strong>bwcx9393</strong>”与我学习交流。</p>
<h2 id="Redis常见问题总结与好文Mark"><a href="#Redis常见问题总结与好文Mark" class="headerlink" title="Redis常见问题总结与好文Mark"></a>Redis常见问题总结与好文Mark</h2><h3 id="什么是Redis？"><a href="#什么是Redis？" class="headerlink" title="什么是Redis？"></a>什么是Redis？</h3><blockquote>
<p>Redis 是一个使用 C 语言写成的，开源的 key-value 数据库。。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。目前，Vmware在资助着redis项目的开发和维护。</p>
</blockquote>
<h3 id="Redis与Memcached的区别与比较"><a href="#Redis与Memcached的区别与比较" class="headerlink" title="Redis与Memcached的区别与比较"></a>Redis与Memcached的区别与比较</h3><p>1 、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</p>
<p>2 、Redis支持数据的备份，即master-slave模式的数据备份。</p>
<p>3 、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中</p>
<p>4、 redis的速度比memcached快很多</p>
<p>5、Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的IO复用模型。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/18/162d7773080d4570?w=621&amp;h=378&amp;f=jpeg&amp;s=45278" alt="Redis与Memcached的区别与比较"></p>
<p>如果想要更详细了解的话，可以查看慕课网上的这篇手记（非常推荐） <strong>：《脚踏两只船的困惑 - Memcached与Redis》</strong>：<a href="https://www.imooc.com/article/23549" target="_blank" rel="noopener">https://www.imooc.com/article/23549</a></p>
<h3 id="Redis与Memcached的选择"><a href="#Redis与Memcached的选择" class="headerlink" title="Redis与Memcached的选择"></a>Redis与Memcached的选择</h3><p><strong>终极策略：</strong> 使用Redis的String类型做的事，都可以用Memcached替换，以此换取更好的性能提升； 除此以外，优先考虑Redis；</p>
<h3 id="使用redis有哪些好处？"><a href="#使用redis有哪些好处？" class="headerlink" title="使用redis有哪些好处？"></a>使用redis有哪些好处？</h3><p>(1) <strong>速度快</strong>，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) </p>
<p>(2)<strong>支持丰富数据类型</strong>，支持string，list，set，sorted set，hash </p>
<p>(3) <strong>支持事务</strong> ：redis对事务是部分支持的，如果是在入队时报错，那么都不会执行；在非入队时报错，那么成功的就会成功执行。详细了解请参考：《Redis事务介绍（四）》：<a href="https://blog.csdn.net/cuipeng0916/article/details/53698774" target="_blank" rel="noopener">https://blog.csdn.net/cuipeng0916/article/details/53698774</a></p>
<p>redis监控：锁的介绍</p>
<p>(4) <strong>丰富的特性</strong>：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p>
<h3 id="Redis常见数据结构使用场景"><a href="#Redis常见数据结构使用场景" class="headerlink" title="Redis常见数据结构使用场景"></a>Redis常见数据结构使用场景</h3><h4 id="1-String"><a href="#1-String" class="headerlink" title="1. String"></a>1. String</h4><blockquote>
<p><strong>常用命令:</strong>  set,get,decr,incr,mget 等。</p>
</blockquote>
<p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。<br>常规key-value缓存应用；<br>常规计数：微博数，粉丝数等。</p>
<h4 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2.Hash"></a>2.Hash</h4><blockquote>
<p><strong>常用命令：</strong> hget,hset,hgetall 等。</p>
</blockquote>
<p>Hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 比如我们可以Hash数据结构来存储用户信息，商品信息等等。</p>
<p><strong>举个例子：</strong> 最近做的一个电商网站项目的首页就使用了redis的hash数据结构进行缓存，因为一个网站的首页访问量是最大的，所以通常网站的首页可以通过redis缓存来提高性能和并发量。我用<strong>jedis客户端</strong>来连接和操作我搭建的redis集群或者单机redis，利用jedis可以很容易的对redis进行相关操作，总的来说从搭一个简单的集群到实现redis作为缓存的整个步骤不难。感兴趣的可以看我昨天写的这篇文章：</p>
<p><strong>《一文轻松搞懂redis集群原理及搭建与使用》：</strong> <a href="https://juejin.im/post/5ad54d76f265da23970759d3" target="_blank" rel="noopener">https://juejin.im/post/5ad54d76f265da23970759d3</a></p>
<h4 id="3-List"><a href="#3-List" class="headerlink" title="3.List"></a>3.List</h4><blockquote>
<p><strong>常用命令:</strong> lpush,rpush,lpop,rpop,lrange等</p>
</blockquote>
<p>list就是链表，Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，最新消息排行等功能都可以用Redis的list结构来实现。</p>
<p>Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>
<h4 id="4-Set"><a href="#4-Set" class="headerlink" title="4.Set"></a>4.Set</h4><blockquote>
<p><strong>常用命令：</strong><br>sadd,spop,smembers,sunion 等</p>
</blockquote>
<p>set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的。<br>当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
<p>在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同喜好、二度好友等功能。</p>
<h4 id="5-Sorted-Set"><a href="#5-Sorted-Set" class="headerlink" title="5.Sorted Set"></a>5.Sorted Set</h4><blockquote>
<p><strong>常用命令：</strong> zadd,zrange,zrem,zcard等</p>
</blockquote>
<p>和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。</p>
<p><strong>举例：</strong> 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用Redis中的SortedSet结构进行存储。</p>
<h3 id="MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）"><a href="#MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）" class="headerlink" title="MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）"></a>MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）</h3><p>　　　相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。redis 提供 6种数据淘汰策略：</p>
<ol>
<li><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><strong>allkeys-lru</strong>：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-enviction</strong>（驱逐）：禁止驱逐数据</li>
</ol>
<h3 id="Redis的并发竞争问题如何解决"><a href="#Redis的并发竞争问题如何解决" class="headerlink" title="Redis的并发竞争问题如何解决?"></a>Redis的并发竞争问题如何解决?</h3><p>Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：</p>
<p>　1.客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。<br>　<br>  2.服务器角度，利用setnx实现锁。</p>
<p>　注：对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用synchronized也可以使用lock；第二种需要用到Redis的setnx命令，但是需要注意一些问题。</p>
<h3 id="Redis回收进程如何工作的-Redis回收使用的是什么算法"><a href="#Redis回收进程如何工作的-Redis回收使用的是什么算法" class="headerlink" title="Redis回收进程如何工作的? Redis回收使用的是什么算法?"></a>Redis回收进程如何工作的? Redis回收使用的是什么算法?</h3><p><strong>Redis内存回收:LRU算法（写的很不错，推荐）</strong>：<a href="https://www.cnblogs.com/WJ5888/p/4371647.html" target="_blank" rel="noopener">https://www.cnblogs.com/WJ5888/p/4371647.html</a></p>
<h3 id="Redis-大量数据插入"><a href="#Redis-大量数据插入" class="headerlink" title="Redis 大量数据插入"></a>Redis 大量数据插入</h3><p>官方文档给的解释：<a href="http://www.redis.cn/topics/mass-insert.html" target="_blank" rel="noopener">http://www.redis.cn/topics/mass-insert.html</a></p>
<h3 id="Redis-分区的优势、不足以及分区类型"><a href="#Redis-分区的优势、不足以及分区类型" class="headerlink" title="Redis 分区的优势、不足以及分区类型"></a>Redis 分区的优势、不足以及分区类型</h3><p>官方文档提供的讲解：<a href="http://www.redis.net.cn/tutorial/3524.html" target="_blank" rel="noopener">http://www.redis.net.cn/tutorial/3524.html</a></p>
<h3 id="Redis持久化数据和缓存怎么做扩容？"><a href="#Redis持久化数据和缓存怎么做扩容？" class="headerlink" title="Redis持久化数据和缓存怎么做扩容？"></a>Redis持久化数据和缓存怎么做扩容？</h3><p><strong>《redis的持久化和缓存机制》</strong> ：<a href="https://blog.csdn.net/tr1912/article/details/70197085?foxhandler=RssReadRenderProcessHandler" target="_blank" rel="noopener">https://blog.csdn.net/tr1912/article/details/70197085?foxhandler=RssReadRenderProcessHandler</a></p>
<p>扩容的话可以通过redis集群实现，之前做项目的时候用过自己搭的redis集群<br>然后写了一篇关于redis集群的文章：<strong>《一文轻松搞懂redis集群原理及搭建与使用》</strong>：<a href="https://juejin.im/post/5ad54d76f265da23970759d3" target="_blank" rel="noopener">https://juejin.im/post/5ad54d76f265da23970759d3</a></p>
<h3 id="Redis常见性能问题和解决方案"><a href="#Redis常见性能问题和解决方案" class="headerlink" title="Redis常见性能问题和解决方案:"></a>Redis常见性能问题和解决方案:</h3><ol>
<li>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件 </li>
<li>如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次 </li>
<li>为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内 </li>
<li>尽量避免在压力很大的主库上增加从库</li>
</ol>
<h3 id="Redis与消息队列"><a href="#Redis与消息队列" class="headerlink" title="Redis与消息队列"></a>Redis与消息队列</h3><blockquote>
<p>作者：翁伟<br>链接：<a href="https://www.zhihu.com/question/20795043/answer/345073457" target="_blank" rel="noopener">https://www.zhihu.com/question/20795043/answer/345073457</a></p>
</blockquote>
<p>不要使用redis去做消息队列，这不是redis的设计目标。但实在太多人使用redis去做去消息队列，redis的作者看不下去，另外基于redis的核心代码，另外实现了一个消息队列disque： antirez/disque:<a href="https://github.com/antirez/disque" target="_blank" rel="noopener">https://github.com/antirez/disque</a>部署、协议等方面都跟redis非常类似，并且支持集群，延迟消息等等。</p>
<p>我在做网站过程接触比较多的还是使用redis做缓存，比如秒杀系统，首页缓存等等。</p>
<h2 id="好文Mark"><a href="#好文Mark" class="headerlink" title="好文Mark"></a>好文Mark</h2><p><strong>非常非常推荐下面几篇文章。。。</strong></p>
<p><strong>《Redis深入之道：原理解析、场景使用以及视频解读》</strong>：<a href="https://zhuanlan.zhihu.com/p/28073983" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28073983</a>:<br>主要介绍了：Redis集群开源的方案、Redis协议简介及持久化Aof文件解析、Redis短连接性能优化等等内容，文章干货太大，容量很大，建议时间充裕可以看看。另外文章里面还提供了视频讲解，可以说是非常非常用心了。</p>
<p><strong>《阿里云Redis混合存储典型场景：如何轻松搭建视频直播间系统》：</strong><a href="https://yq.aliyun.com/articles/582487?utm_content=m_46529" target="_blank" rel="noopener">https://yq.aliyun.com/articles/582487?utm_content=m_46529</a>:<br>主要介绍视频直播间系统，以及如何使用阿里云Redis混合存储实例方便快捷的构建大数据量，低延迟的视频直播间服务。还介绍到了我们之前提高过的redis的数据结构的使用场景</p>
<p><strong>《美团在Redis上踩过的一些坑-5.redis cluster遇到的一些问》</strong>：<a href="http://carlosfu.iteye.com/blog/2254573" target="_blank" rel="noopener">http://carlosfu.iteye.com/blog/2254573</a>：主要介绍了redis集群的两个常见问题，然后分享了 一些关于redis集群不错的文章。</p>
<p><strong>参考：</strong></p>
<p><a href="https://www.cnblogs.com/Survivalist/p/8119891.html" target="_blank" rel="noopener">https://www.cnblogs.com/Survivalist/p/8119891.html</a></p>
<p><a href="http://www.redis.net.cn/tutorial/3524.html" target="_blank" rel="noopener">http://www.redis.net.cn/tutorial/3524.html</a></p>
<p><a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-07-30T03:02:35.814Z"><a href="/2018/07/30/数据结构与算法/算法/">2018-07-30</a></time>
      
      
  
    <h1 class="title"><a href="/2018/07/30/数据结构与算法/算法/"></a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">LeetCode（中国）官网</a></p>
<p><a href="https://leetcode-cn.com/articles/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%9C%B0%E4%BD%BF%E7%94%A8-leetcode/" target="_blank" rel="noopener">如何高效地使用 LeetCode</a></p>
<h2 id="牛客网："><a href="#牛客网：" class="headerlink" title="牛客网："></a>牛客网：</h2><p><a href="https://www.nowcoder.com" target="_blank" rel="noopener">牛客网首页</a></p>
<blockquote>
<h3 id="剑指offer编程题"><a href="#剑指offer编程题" class="headerlink" title="剑指offer编程题"></a><strong><a href="https://www.nowcoder.com/ta/coding-interviews" target="_blank" rel="noopener">剑指offer编程题</a></strong></h3></blockquote>
<p><strong>分类解析：</strong></p>
<ul>
<li><a href="https://github.com/Snailclimb/Java-Guide/tree/master/数据结构与算法/算法题解析/剑指offer/（1）斐波那契数列问题和跳台阶问题.md" target="_blank" rel="noopener">（1）斐波那契数列问题和跳台阶问题</a></li>
<li><a href="https://github.com/Snailclimb/Java-Guide/tree/master/数据结构与算法/算法题解析/剑指offer/（2）二维数组查找和替换空格问题.md" target="_blank" rel="noopener">（2）二维数组查找和替换空格问题</a></li>
<li><a href="https://github.com/Snailclimb/Java-Guide/tree/master/数据结构与算法/算法题解析/剑指offer/（3）数值的整数次方和调整数组元素顺序.md" target="_blank" rel="noopener">（3）数值的整数次方和调整数组元素顺序</a></li>
<li><a href="https://github.com/Snailclimb/Java-Guide/tree/master/数据结构与算法/算法题解析/剑指offer/（4）链表相关编程题.md" target="_blank" rel="noopener">（4）链表相关编程题</a></li>
<li><a href="https://github.com/Snailclimb/Java-Guide/tree/master/数据结构与算法/算法题解析/剑指offer/（5）栈变队列和栈的压入、弹出序列.md" target="_blank" rel="noopener">（5）栈变队列和栈的压入、弹出序列</a></li>
</ul>
<blockquote>
<h3 id="2017校招真题"><a href="#2017校招真题" class="headerlink" title="2017校招真题"></a><a href="https://www.nowcoder.com/ta/2017test" target="_blank" rel="noopener">2017校招真题</a></h3></blockquote>
<blockquote>
<h3 id="华为机试题"><a href="#华为机试题" class="headerlink" title="华为机试题"></a><a href="https://www.nowcoder.com/ta/huawei" target="_blank" rel="noopener">华为机试题</a></h3></blockquote>
<h2 id="公司真题"><a href="#公司真题" class="headerlink" title="公司真题"></a>公司真题</h2><blockquote>
<p><a href="https://www.nowcoder.com/test/6910869/summary" target="_blank" rel="noopener"> 网易2018校园招聘编程题真题集合</a></p>
</blockquote>
<p><strong>解析：</strong></p>
<ul>
<li><a href="https://github.com/Snailclimb/Java-Guide/tree/master/数据结构与算法/算法题解析/公司真题/网易2018校招编程题1-3.md" target="_blank" rel="noopener"> 网易2018校招编程题1-3</a></li>
</ul>
<blockquote>
<p><a href="https://www.nowcoder.com/test/6291726/summary" target="_blank" rel="noopener"> 网易2018校招内推编程题集合</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.nowcoder.com/test/5986669/summary" target="_blank" rel="noopener">2017年校招全国统一模拟笔试(第五场)编程题集合</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.nowcoder.com/test/5507925/summary" target="_blank" rel="noopener">2017年校招全国统一模拟笔试(第四场)编程题集合</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.nowcoder.com/test/5217106/summary" target="_blank" rel="noopener">2017年校招全国统一模拟笔试(第三场)编程题集合</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.nowcoder.com/test/4546329/summary" target="_blank" rel="noopener">2017年校招全国统一模拟笔试(第二场)编程题集合</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.nowcoder.com/test/4236887/summary" target="_blank" rel="noopener"> 2017年校招全国统一模拟笔试(第一场)编程题集合</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.nowcoder.com/test/4998655/summary" target="_blank" rel="noopener">百度2017春招笔试真题编程题集合</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.nowcoder.com/test/4575457/summary" target="_blank" rel="noopener">网易2017春招笔试真题编程题集合</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.nowcoder.com/test/2811407/summary" target="_blank" rel="noopener">网易2017秋招编程题集合</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.nowcoder.com/test/2385858/summary" target="_blank" rel="noopener">网易有道2017内推编程题</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.nowcoder.com/test/3701760/summary" target="_blank" rel="noopener"> 滴滴出行2017秋招笔试真题-编程题汇总</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.nowcoder.com/test/1725829/summary" target="_blank" rel="noopener">腾讯2017暑期实习生编程题</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.nowcoder.com/test/1649301/summary" target="_blank" rel="noopener">今日头条2017客户端工程师实习生笔试题</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.nowcoder.com/test/1649268/summary" target="_blank" rel="noopener">今日头条2017后端工程师实习生笔试题</a></p>
</blockquote>
<h2 id="排序算法："><a href="#排序算法：" class="headerlink" title="排序算法："></a>排序算法：</h2><p><a href="http://www.cnblogs.com/chengxiao/p/6103002.html" target="_blank" rel="noopener">图解排序算法(一)之3种简单排序(选择，冒泡，直接插入)</a></p>
<p><a href="https://www.cnblogs.com/chengxiao/p/6104371.html" target="_blank" rel="noopener">图解排序算法(二)之希尔排序</a></p>
<p><a href="http://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">图解排序算法(三)之堆排序</a></p>
<p><a href="http://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">图解排序算法(四)之归并排序</a></p>
<p><a href="http://www.cnblogs.com/chengxiao/p/6262208.html" target="_blank" rel="noopener">图解排序算法(五)之快速排序——三数取中法</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-07-30T03:02:35.798Z"><a href="/2018/07/30/架构/分布式/">2018-07-30</a></time>
      
      
  
    <h1 class="title"><a href="/2018/07/30/架构/分布式/"></a></h1>
  

    </header>
    <div class="entry">
      
        <ul>
<li><h3 id="一-分布式系统的经典基础理论"><a href="#一-分布式系统的经典基础理论" class="headerlink" title="一　分布式系统的经典基础理论"></a>一　分布式系统的经典基础理论</h3><p><a href="https://blog.csdn.net/qq_34337272/article/details/80444032" target="_blank" rel="noopener">分布式系统的经典基础理论</a></p>
<p> 本文主要是简单的介绍了三个常见的概念： <strong>分布式系统设计理念</strong> 、 <strong>CAP定理</strong> 、 <strong>BASE理论</strong> ，关于分布式系统的还有很多很多东西。<br><img src="https://user-gold-cdn.xitu.io/2018/5/24/1639234237ec9805?w=791&amp;h=466&amp;f=png&amp;s=55908" alt="分布式系统的经典基础理论总结"></p>
</li>
<li><h3 id="二-分布式事务"><a href="#二-分布式事务" class="headerlink" title="二　分布式事务"></a>二　分布式事务</h3><p>分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。以上是百度百科的解释，简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。</p>
<ul>
<li><a href="http://www.codeceo.com/article/distributed-transaction.html" target="_blank" rel="noopener">深入理解分布式事务</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25933039" target="_blank" rel="noopener">分布式事务？No, 最终一致性</a></li>
<li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a>
　　</li>
</ul>
</li>
<li><h3 id="三-分布式系统一致性"><a href="#三-分布式系统一致性" class="headerlink" title="三　分布式系统一致性"></a>三　分布式系统一致性</h3><p><a href="https://www.jianshu.com/p/1156151e20c8" target="_blank" rel="noopener">分布式服务化系统一致性的“最佳实干”</a></p>
<ul>
<li><h3 id="四-一致性协议-算法"><a href="#四-一致性协议-算法" class="headerlink" title="四　一致性协议/算法"></a>四　一致性协议/算法</h3>早在1898年就诞生了著名的 <strong>Paxos经典算法</strong> （<strong>Zookeeper就采用了Paxos算法的近亲兄弟Zab算法</strong>），但由于Paxos算法非常难以理解、实现、排错。所以不断有人尝试简化这一算法，直到2013年才有了重大突破：斯坦福的Diego Ongaro、John Ousterhout以易懂性为目标设计了新的一致性算法—— <strong>Raft算法</strong> ，并发布了对应的论文《In Search of an Understandable Consensus Algorithm》，到现在有十多种语言实现的Raft算法框架，较为出名的有以Go语言实现的Etcd，它的功能类似于Zookeeper，但采用了更为主流的Rest接口。<ul>
<li><a href="http://blog.xiaohansong.com/2016/09/30/Paxos/" target="_blank" rel="noopener">图解 Paxos 一致性协议</a></li>
<li><a href="http://ifeve.com/raft/" target="_blank" rel="noopener">图解分布式协议-RAFT</a></li>
<li><a href="http://blog.xiaohansong.com/2016/08/25/zab/" target="_blank" rel="noopener">Zookeeper ZAB 协议分析</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><h3 id="五-分布式存储"><a href="#五-分布式存储" class="headerlink" title="五　分布式存储"></a>五　分布式存储</h3><p><strong>分布式存储系统将数据分散存储在多台独立的设备上</strong>。传统的网络存储系统采用集中的存储服务器存放所有数据，存储服务器成为系统性能的瓶颈，也是可靠性和安全性的焦点，不能满足大规模存储应用的需要。分布式网络存储系统采用可扩展的系统结构，利用多台存储服务器分担存储负荷，利用位置服务器定位存储信息，它不但提高了系统的可靠性、可用性和存取效率，还易于扩展。 </p>
<ul>
<li><a href="http://witchiman.top/2017/05/05/distributed-system/" target="_blank" rel="noopener">分布式存储系统概要</a></li>
</ul>
</li>
<li><h3 id="六-分布式计算"><a href="#六-分布式计算" class="headerlink" title="六　分布式计算"></a>六　分布式计算</h3><p><strong>所谓分布式计算是一门计算机科学，它研究如何把一个需要非常巨大的计算能力才能解决的问题分成许多小的部分，然后把这些部分分配给许多计算机进行处理，最后把这些计算结果综合起来得到最终的结果。</strong><br>分布式网络存储技术是将数据分散的存储于多台独立的机器设备上。分布式网络存储系统采用可扩展的系统结构，利用多台存储服务器分担存储负荷，利用位置服务器定位存储信息，不但解决了传统集中式存储系统中单存储服务器的瓶颈问题，还提高了系统的可靠性、可用性和扩展性。</p>
<ul>
<li><a href="https://blog.csdn.net/qq_34337272/article/details/80549020" target="_blank" rel="noopener">关于分布式计算的一些概念</a></li>
</ul>
</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-07-30T03:02:35.798Z"><a href="/2018/07/30/面试必备/程序员的简历之道/">2018-07-30</a></time>
      
      
  
    <h1 class="title"><a href="/2018/07/30/面试必备/程序员的简历之道/"></a></h1>
  

    </header>
    <div class="entry">
      
        <p><img src="https://user-gold-cdn.xitu.io/2018/7/25/164cf5c26e88cbcd?w=1024&amp;h=902&amp;f=jpeg&amp;s=94869" alt="程序员的简历之道"></p>
<blockquote>
<p>俗话说的好：“工欲善其事，必先利其器”。准备一份好的简历对于能不能找到一份好工作起到了至关重要的作用。</p>
</blockquote>
<h2 id="六-如何写自己的简历？"><a href="#六-如何写自己的简历？" class="headerlink" title="六 如何写自己的简历？"></a>六 如何写自己的简历？</h2><font color="red">一份好的简历可以在整个申请面试以及面试过程中起到非常好的作用。</font>

<h3 id="6-1-为什么说简历很重要？"><a href="#6-1-为什么说简历很重要？" class="headerlink" title="6.1 为什么说简历很重要？"></a>6.1 为什么说简历很重要？</h3><p>假如你是网申，你的简历必然会经过HR的筛选，一张简历HR可能也就花费10秒钟看一下，然后HR就会决定你这一关是Fail还是Pass。</p>
<p>假如你是内推，如果你的简历没有什么优势的话，就算是内推你的人再用心，也无能为力。</p>
<p>另外，就算你通过了筛选，后面的面试中，面试官也会根据你的简历来判断你究竟是否值得他花费很多时间去面试。</p>
<h3 id="6-2-这3点你必须知道"><a href="#6-2-这3点你必须知道" class="headerlink" title="6.2 这3点你必须知道"></a>6.2 这3点你必须知道</h3><ol>
<li><strong>大部分应届生找工作的硬伤是没有工作经验或实习经历；</strong></li>
<li><strong>写在简历上的东西一定要慎重，这可能是面试官大量提问的地方；</strong></li>
<li><strong>将自己的项目经历完美的展示出来非常重要。</strong></li>
</ol>
<h3 id="6-3-两大法则了解一下"><a href="#6-3-两大法则了解一下" class="headerlink" title="6.3 两大法则了解一下"></a>6.3 两大法则了解一下</h3><p>目前写简历的方式有两种普遍被认可，一种是 STAR， 一种是 FAB。</p>
<p><strong>STAR法则（Situation Task Action Result）：</strong></p>
<ul>
<li><strong>Situation：</strong> 事情是在什么情况下发生；</li>
<li><strong>Task:：</strong> 你是如何明确你的任务的；</li>
<li><strong>Action：</strong> 针对这样的情况分析，你采用了什么行动方式；</li>
<li><strong>Result：</strong> 结果怎样，在这样的情况下你学习到了什么。</li>
</ul>
<p><strong>FAB 法则（Feature Advantage Benefit）：</strong></p>
<ul>
<li><strong>Feature：</strong> 是什么；</li>
<li><strong>Advantage：</strong> 比别人好在哪些地方；</li>
<li><strong>Benefit：</strong> 如果雇佣你，招聘方会得到什么好处。</li>
</ul>
<h3 id="6-4-项目经历怎么写？"><a href="#6-4-项目经历怎么写？" class="headerlink" title="6.4 项目经历怎么写？"></a>6.4 项目经历怎么写？</h3><p>简历上有一两个项目经历很正常，但是真正能把项目经历很好的展示给面试官的非常少。对于项目经历大家可以考虑从如下几点来写：</p>
<ol>
<li>对项目整体设计的一个感受</li>
<li>在这个项目中你负责了什么、做了什么、担任了什么角色</li>
<li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</li>
<li>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的。</li>
</ol>
<h3 id="6-5-专业技能该怎么写？"><a href="#6-5-专业技能该怎么写？" class="headerlink" title="6.5 专业技能该怎么写？"></a>6.5 专业技能该怎么写？</h3><p>先问一下你自己会什么，然后看看你意向的公司需要什么。一般HR可能并不太懂技术，所以他在筛选简历的时候可能就盯着你专业技能的关键词来看。对于公司有要求而你不会的技能，你可以花几天时间学习一下，然后在简历上可以写上自己了解这个技能。比如你可以这样写：</p>
<ul>
<li>Dubbo：精通</li>
<li>Spring：精通</li>
<li>Docker：掌握</li>
<li>SOA分布式开发 ：掌握</li>
<li>Spring Cloud:了解</li>
</ul>
<h3 id="6-6-开源程序员简历模板分享"><a href="#6-6-开源程序员简历模板分享" class="headerlink" title="6.6 开源程序员简历模板分享"></a>6.6 开源程序员简历模板分享</h3><p>分享一个Github上开源的程序员简历模板。包括PHP程序员简历模板、iOS程序员简历模板、Android程序员简历模板、Web前端程序员简历模板、Java程序员简历模板、C/C++程序员简历模板、NodeJS程序员简历模板、架构师简历模板以及通用程序员简历模板 。<br>Github地址：<a href="https://github.com/geekcompany/ResumeSample" target="_blank" rel="noopener">https://github.com/geekcompany/ResumeSample</a></p>
<h3 id="6-7-其他的一些小tips"><a href="#6-7-其他的一些小tips" class="headerlink" title="6.7 其他的一些小tips"></a>6.7 其他的一些小tips</h3><ol>
<li>尽量避免主观表述，少一点语义模糊的形容词，尽量要简洁明了，逻辑结构清晰。</li>
<li>注意排版（不需要花花绿绿的），尽量使用Markdown语法。</li>
<li>如果自己有博客或者个人技术栈点的话，写上去会为你加分很多。</li>
<li>如果自己的Github比较活跃的话，写上去也会为你加分很多。</li>
<li>注意简历真实性，一定不要写自己不会的东西，或者带有欺骗性的内容</li>
<li>项目经历建议以时间倒序排序，另外项目经历不在于多，而在于有亮点。</li>
<li>如果内容过多的话，不需要非把内容压缩到一页，保持排版干净整洁就可以了。</li>
<li>简历最后最好能加上：“感谢您花时间阅读我的简历，期待能有机会和您共事。”这句话，显的你会很有礼貌。</li>
</ol>
<p>本文摘自我的Gitchat:<a href="https://gitbook.cn/gitchat/activity/5b457a5df64d4d62e64a449a" target="_blank" rel="noopener">《从应届程序员角度分析如何备战大厂面试》</a>。<br><img src="https://user-gold-cdn.xitu.io/2018/7/25/164cf5c26e88cbcd?w=1024&amp;h=902&amp;f=jpeg&amp;s=94869" alt="程序员的简历之道"></p>
<blockquote>
<p>俗话说的好：“工欲善其事，必先利其器”。准备一份好的简历对于能不能找到一份好工作起到了至关重要的作用。</p>
</blockquote>
<h2 id="六-如何写自己的简历？-1"><a href="#六-如何写自己的简历？-1" class="headerlink" title="六 如何写自己的简历？"></a>六 如何写自己的简历？</h2><font color="red">一份好的简历可以在整个申请面试以及面试过程中起到非常好的作用。</font>

<h3 id="6-1-为什么说简历很重要？-1"><a href="#6-1-为什么说简历很重要？-1" class="headerlink" title="6.1 为什么说简历很重要？"></a>6.1 为什么说简历很重要？</h3><p>假如你是网申，你的简历必然会经过HR的筛选，一张简历HR可能也就花费10秒钟看一下，然后HR就会决定你这一关是Fail还是Pass。</p>
<p>假如你是内推，如果你的简历没有什么优势的话，就算是内推你的人再用心，也无能为力。</p>
<p>另外，就算你通过了筛选，后面的面试中，面试官也会根据你的简历来判断你究竟是否值得他花费很多时间去面试。</p>
<h3 id="6-2-这3点你必须知道-1"><a href="#6-2-这3点你必须知道-1" class="headerlink" title="6.2 这3点你必须知道"></a>6.2 这3点你必须知道</h3><ol>
<li><strong>大部分应届生找工作的硬伤是没有工作经验或实习经历；</strong></li>
<li><strong>写在简历上的东西一定要慎重，这可能是面试官大量提问的地方；</strong></li>
<li><strong>将自己的项目经历完美的展示出来非常重要。</strong></li>
</ol>
<h3 id="6-3-两大法则了解一下-1"><a href="#6-3-两大法则了解一下-1" class="headerlink" title="6.3 两大法则了解一下"></a>6.3 两大法则了解一下</h3><p>目前写简历的方式有两种普遍被认可，一种是 STAR， 一种是 FAB。</p>
<p><strong>STAR法则（Situation Task Action Result）：</strong></p>
<ul>
<li><strong>Situation：</strong> 事情是在什么情况下发生；</li>
<li><strong>Task:：</strong> 你是如何明确你的任务的；</li>
<li><strong>Action：</strong> 针对这样的情况分析，你采用了什么行动方式；</li>
<li><strong>Result：</strong> 结果怎样，在这样的情况下你学习到了什么。</li>
</ul>
<p><strong>FAB 法则（Feature Advantage Benefit）：</strong></p>
<ul>
<li><strong>Feature：</strong> 是什么；</li>
<li><strong>Advantage：</strong> 比别人好在哪些地方；</li>
<li><strong>Benefit：</strong> 如果雇佣你，招聘方会得到什么好处。</li>
</ul>
<h3 id="6-4-项目经历怎么写？-1"><a href="#6-4-项目经历怎么写？-1" class="headerlink" title="6.4 项目经历怎么写？"></a>6.4 项目经历怎么写？</h3><p>简历上有一两个项目经历很正常，但是真正能把项目经历很好的展示给面试官的非常少。对于项目经历大家可以考虑从如下几点来写：</p>
<ol>
<li>对项目整体设计的一个感受</li>
<li>在这个项目中你负责了什么、做了什么、担任了什么角色</li>
<li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</li>
<li>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的。</li>
</ol>
<h3 id="6-5-专业技能该怎么写？-1"><a href="#6-5-专业技能该怎么写？-1" class="headerlink" title="6.5 专业技能该怎么写？"></a>6.5 专业技能该怎么写？</h3><p>先问一下你自己会什么，然后看看你意向的公司需要什么。一般HR可能并不太懂技术，所以他在筛选简历的时候可能就盯着你专业技能的关键词来看。对于公司有要求而你不会的技能，你可以花几天时间学习一下，然后在简历上可以写上自己了解这个技能。比如你可以这样写：</p>
<ul>
<li>Dubbo：精通</li>
<li>Spring：精通</li>
<li>Docker：掌握</li>
<li>SOA分布式开发 ：掌握</li>
<li>Spring Cloud:了解</li>
</ul>
<h3 id="6-6-开源程序员简历模板分享-1"><a href="#6-6-开源程序员简历模板分享-1" class="headerlink" title="6.6 开源程序员简历模板分享"></a>6.6 开源程序员简历模板分享</h3><p>分享一个Github上开源的程序员简历模板。包括PHP程序员简历模板、iOS程序员简历模板、Android程序员简历模板、Web前端程序员简历模板、Java程序员简历模板、C/C++程序员简历模板、NodeJS程序员简历模板、架构师简历模板以及通用程序员简历模板 。<br>Github地址：<a href="https://github.com/geekcompany/ResumeSample" target="_blank" rel="noopener">https://github.com/geekcompany/ResumeSample</a></p>
<h3 id="6-7-其他的一些小tips-1"><a href="#6-7-其他的一些小tips-1" class="headerlink" title="6.7 其他的一些小tips"></a>6.7 其他的一些小tips</h3><ol>
<li>尽量避免主观表述，少一点语义模糊的形容词，尽量要简洁明了，逻辑结构清晰。</li>
<li>注意排版（不需要花花绿绿的），尽量使用Markdown语法。</li>
<li>如果自己有博客或者个人技术栈点的话，写上去会为你加分很多。</li>
<li>如果自己的Github比较活跃的话，写上去也会为你加分很多。</li>
<li>注意简历真实性，一定不要写自己不会的东西，或者带有欺骗性的内容</li>
<li>项目经历建议以时间倒序排序，另外项目经历不在于多，而在于有亮点。</li>
<li>如果内容过多的话，不需要非把内容压缩到一页，保持排版干净整洁就可以了。</li>
<li>简历最后最好能加上：“感谢您花时间阅读我的简历，期待能有机会和您共事。”这句话，显的你会很有礼貌。</li>
</ol>
<p>本文摘自我的Gitchat:<a href="https://gitbook.cn/gitchat/activity/5b457a5df64d4d62e64a449a" target="_blank" rel="noopener">《从应届程序员角度分析如何备战大厂面试》</a>。</p>
<blockquote>
<p>如果想要获取更多我的原创文章，欢迎关注我的微信公众号:”<strong>Java面试通关手册</strong>“ 。无套路，希望能与您共同进步，互相学习。</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/5/1646a3d308a8db1c?w=258&amp;h=258&amp;f=jpeg&amp;s=27034" alt=""></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-07-30T03:02:35.798Z"><a href="/2018/07/30/面试必备/面试必备之乐观锁与悲观锁/">2018-07-30</a></time>
      
      
  
    <h1 class="title"><a href="/2018/07/30/面试必备/面试必备之乐观锁与悲观锁/"></a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="何谓悲观锁与乐观锁"><a href="#何谓悲观锁与乐观锁" class="headerlink" title="何谓悲观锁与乐观锁"></a>何谓悲观锁与乐观锁</h3><blockquote>
<p>乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。</p>
</blockquote>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>，像数据库提供的类似于<strong>write_condition机制</strong>，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的。</p>
<h4 id="两种锁的使用场景"><a href="#两种锁的使用场景" class="headerlink" title="两种锁的使用场景"></a>两种锁的使用场景</h4><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></p>
<h3 id="乐观锁常见的两种实现方式"><a href="#乐观锁常见的两种实现方式" class="headerlink" title="乐观锁常见的两种实现方式"></a>乐观锁常见的两种实现方式</h3><blockquote>
<p><strong>乐观锁一般会使用版本号机制或CAS算法实现。</strong></p>
</blockquote>
<h4 id="1-版本号机制"><a href="#1-版本号机制" class="headerlink" title="1. 版本号机制"></a>1. 版本号机制</h4><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p><strong>举一个简单的例子：</strong><br>假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p>
<ol>
<li>操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li>
<li>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li>
<li>操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</li>
<li>操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li>
</ol>
<p>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p>
<h4 id="2-CAS算法"><a href="#2-CAS算法" class="headerlink" title="2. CAS算法"></a>2. CAS算法</h4><p>即<strong>compare and swap（比较与交换）</strong>，是一种有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。<strong>CAS算法</strong>涉及到三个操作数</p>
<ul>
<li>需要读写的内存值 V </li>
<li>进行比较的值 A </li>
<li>拟写入的新值 B</li>
</ul>
<p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个<strong>自旋操作</strong>，即<strong>不断的重试</strong>。</p>
<p>关于自旋锁，大家可以看一下这篇文章，非常不错：<a href="https://blog.csdn.net/qq_34337272/article/details/81252853" target="_blank" rel="noopener">《<br>面试必备之深入理解自旋锁》</a></p>
<h3 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h3><blockquote>
<p> ABA 问题是乐观锁一个常见的问题</p>
</blockquote>
<h4 id="1-ABA-问题"><a href="#1-ABA-问题" class="headerlink" title="1 ABA 问题"></a>1 ABA 问题</h4><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 <strong>“ABA”问题。</strong></p>
<p>JDK 1.5 以后的 <code>AtomicStampedReference 类</code>就提供了此种能力，其中的 <code>compareAndSet 方法</code>就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<h4 id="2-循环时间长开销大"><a href="#2-循环时间长开销大" class="headerlink" title="2 循环时间长开销大"></a>2 循环时间长开销大</h4><p><strong>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</strong> 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
<h4 id="3-只能保证一个共享变量的原子操作"><a href="#3-只能保证一个共享变量的原子操作" class="headerlink" title="3 只能保证一个共享变量的原子操作"></a>3 只能保证一个共享变量的原子操作</h4><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了<code>AtomicReference类</code>来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference类</code>把多个共享变量合并成一个共享变量来操作。</p>
<h3 id="CAS与synchronized的使用情景"><a href="#CAS与synchronized的使用情景" class="headerlink" title="CAS与synchronized的使用情景"></a>CAS与synchronized的使用情景</h3><blockquote>
<p><strong>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</strong></p>
</blockquote>
<ol>
<li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li>
<li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li>
</ol>
<p>补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 <strong>“重量级锁”</strong> 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 <strong>偏向锁</strong> 和 <strong>轻量级锁</strong> 以及其它<strong>各种优化</strong>之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 <strong>Lock-Free</strong> 的队列，基本思路是 <strong>自旋后阻塞</strong>，<strong>竞争切换后继续竞争锁</strong>，<strong>稍微牺牲了公平性，但获得了高吞吐量</strong>。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-07-30T03:02:35.783Z"><a href="/2018/07/30/计算机网络与数据通信/计算机网络/">2018-07-30</a></time>
      
      
  
    <h1 class="title"><a href="/2018/07/30/计算机网络与数据通信/计算机网络/"></a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="一-OSI与TCP-IP各层的结构与功能，都有哪些协议"><a href="#一-OSI与TCP-IP各层的结构与功能，都有哪些协议" class="headerlink" title="一 OSI与TCP/IP各层的结构与功能，都有哪些协议"></a>一 OSI与TCP/IP各层的结构与功能，都有哪些协议</h2><p>OSI的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用。在这里顺带提一下之前一直被一些大公司甚至一些国家政府支持的OSI失败的原因： </p>
<ol>
<li>OSI的专家缺乏实际经验，他们在完成OSI标准时缺乏商业驱动力 </li>
<li>OSI的协议实现起来过分复杂，而且运行效率很低 </li>
<li>OSI制定标准的周期太长，因而使得按OSI标准生产的设备无法及时进入市场（20世纪90年代初期，虽然整套的OSI国际标准都已经制定出来，但基于TCP/IP的互联网已经抢先在全球相当大的范围成功运行了） </li>
<li>OSI的层次划分不太合理，有些功能在多个层次中重复出现</li>
</ol>
<h3 id="五层协议的体系结构"><a href="#五层协议的体系结构" class="headerlink" title="五层协议的体系结构"></a>五层协议的体系结构</h3><p>学习计算机网络时我们一般采用折中的办法，也就是中和OSI和TCP/IP的有点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/29/164e5307471e8eba?w=633&amp;h=344&amp;f=png&amp;s=164623" alt="五层协议的体系结构"></p>
<p>结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用。</p>
<h3 id="1-应用层（application-layer）"><a href="#1-应用层（application-layer）" class="headerlink" title="1 应用层（application layer）"></a>1 应用层（application layer）</h3><p><strong>应用层的任务是通过应用进程间的交互来完成特定网络应用。</strong>应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如<strong>域名系统DNS</strong>，支持万维网应用的<strong>HTTP协议</strong>，支持电子邮件的<strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文。</p>
<h4 id="域名系统（Domain-Name-System缩写DNS，Domain-Name被译为域名）"><a href="#域名系统（Domain-Name-System缩写DNS，Domain-Name被译为域名）" class="headerlink" title="域名系统（Domain Name System缩写DNS，Domain Name被译为域名）"></a>域名系统（Domain Name System缩写DNS，Domain Name被译为域名）</h4><blockquote>
<p>域名系统是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的Web网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM公司的域名是<a href="http://www.ibm.com、Oracle公司的域名是www.oracle.com、Cisco公司的域名是www.cisco.com等。" target="_blank" rel="noopener">www.ibm.com、Oracle公司的域名是www.oracle.com、Cisco公司的域名是www.cisco.com等。</a></p>
</blockquote>
<h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><blockquote>
<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。（百度百科）</p>
</blockquote>
<h3 id="2-运输层（transport-layer）"><a href="#2-运输层（transport-layer）" class="headerlink" title="2 运输层（transport layer）"></a>2 运输层（transport layer）</h3><p><strong>运输层的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<h4 id="运输层主要使用以下两种协议："><a href="#运输层主要使用以下两种协议：" class="headerlink" title="运输层主要使用以下两种协议："></a>运输层主要使用以下两种协议：</h4><ol>
<li><strong>传输控制协议TCP</strong>（Transmisson Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li>
<li><strong>用户数据协议UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li>
</ol>
<h4 id="UDP的主要特点："><a href="#UDP的主要特点：" class="headerlink" title="UDP的主要特点："></a>UDP的主要特点：</h4><ol>
<li>UDP是无连接的；</li>
<li>UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</li>
<li>UDP是面向报文的；</li>
<li>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；</li>
<li>UDP支持一对一、一对多、多对一和多对多的交互通信；</li>
<li>UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</li>
</ol>
<h4 id="TCP的主要特点："><a href="#TCP的主要特点：" class="headerlink" title="TCP的主要特点："></a>TCP的主要特点：</h4><ol>
<li>TCP是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</li>
<li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；</li>
<li>TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</li>
<li>TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li>
<li>面向字节流。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li>
</ol>
<h3 id="3-网络层（network-layer）"><a href="#3-网络层（network-layer）" class="headerlink" title="3 网络层（network layer）"></a>3 网络层（network layer）</h3><p><strong>网络层负责为分组交换网上的不同主机提供通信服务。</strong>在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在TCP/IP体系结构中，由于网络层使用<strong>IP协议</strong>，因此分组也叫<strong>IP数据报</strong>，简称<strong>数据报</strong>。</p>
<p>这里要注意：<strong>不要把运输层的“用户数据报UDP”和网络层的“IP数据报”弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p>
<p>网络层的另一个任务就是选择合适的路由，使源主机运输层所传下来的分株，能通过网络层中的路由器找到目的主机。</p>
<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。</p>
<h3 id="4-数据链路层（data-link-layer）"><a href="#4-数据链路层（data-link-layer）" class="headerlink" title="4 数据链路层（data link layer）"></a>4 数据链路层（data link layer）</h3><p><strong>数据链路层通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的IP数据报组装程帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。<br>控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>
<h3 id="5-物理层（physical-layer）"><a href="#5-物理层（physical-layer）" class="headerlink" title="5 物理层（physical layer）"></a>5 物理层（physical layer）</h3><p>在物理层上所传送的数据单位是比特。<br><strong>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong>使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<p>在互联网使用的各种协中最重要和最著名的就是TCP/IP两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。</p>
<p>上面我们对计算机网络的五层体系结构有了初步的了解，下面附送一张七层体系结构图总结一下。图片来源：<a href="https://blog.csdn.net/yaopeng_2005/article/details/7064869" target="_blank" rel="noopener">https://blog.csdn.net/yaopeng_2005/article/details/7064869</a><br><img src="https://user-gold-cdn.xitu.io/2018/7/29/164e529309f0fa33?w=1120&amp;h=1587&amp;f=gif&amp;s=225325" alt="七层体系结构图"></p>
<h2 id="二-TCP三次握手和四次挥手（面试常客）"><a href="#二-TCP三次握手和四次挥手（面试常客）" class="headerlink" title="二 TCP三次握手和四次挥手（面试常客）"></a>二 TCP三次握手和四次挥手（面试常客）</h2><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p>
<p><strong>漫画图解：</strong></p>
<p>图片来源：《图解HTTP》<br><img src="https://user-gold-cdn.xitu.io/2018/5/8/1633e127396541f1?w=864&amp;h=439&amp;f=png&amp;s=226095" alt="TCP三次握手"></p>
<p><strong>简单示意图：</strong><br><img src="https://user-gold-cdn.xitu.io/2018/5/8/1633e14233d95972?w=542&amp;h=427&amp;f=jpeg&amp;s=15088" alt="TCP三次握手"></p>
<ul>
<li>客户端–发送带有SYN标志的数据包–一次握手–服务端</li>
<li>服务端–发送带有SYN/ACK标志的数据包–二次握手–客户端</li>
<li>客户端–发送带有带有ACK标志的数据包–三次握手–服务端</li>
</ul>
<p><strong>为什么要传回SYN（发起一个新链接）？</strong></p>
<p>接收端传回发送端所发送的SYN是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
<p><strong>传了SYN，为啥还要传ACK（确认序号有效）？</strong></p>
<p>双方通信无误必须是两者互相发送信息都无误。传了SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要ACK信号来进行验证。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/8/1633e1676e2ac0a3?w=500&amp;h=340&amp;f=jpeg&amp;s=13406" alt="TCP四次挥手"></p>
<p>断开一个TCP连接则需要“四次挥手”：</p>
<ul>
<li>客户端-发送一个FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个FIN，它发回一个ACK，确认序号为收到的序号加1 。和SYN一样，一个FIN将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li>
<li>客户端-发回ACK报文确认，并将确认序号设置为收到序号加1</li>
</ul>
<h3 id="三-TCP、UDP协议的区别"><a href="#三-TCP、UDP协议的区别" class="headerlink" title="三 TCP、UDP协议的区别"></a>三 TCP、UDP协议的区别</h3><p><img src="https://user-gold-cdn.xitu.io/2018/4/19/162db5e97e9a9e01?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="TCP、UDP协议的区别"></p>
<p>UDP在传送数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP确是一种最有效的工作方式（一般用于即时通信），比如： QQ语音 QQ视频 、直播等等</p>
<p>TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的，面向连接的运输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
<h3 id="四-在浏览器中输入url地址-gt-gt-显示主页的过程（面试常客）"><a href="#四-在浏览器中输入url地址-gt-gt-显示主页的过程（面试常客）" class="headerlink" title="四 在浏览器中输入url地址 -&gt;&gt; 显示主页的过程（面试常客）"></a>四 在浏览器中输入url地址 -&gt;&gt; 显示主页的过程（面试常客）</h3><p>百度好像最喜欢问这个问题。</p>
<blockquote>
<p>打开一个网页，整个过程会使用哪些协议</p>
</blockquote>
<p>图片来源：《图解HTTP》</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/19/162db5e985aabdbe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="状态码"></p>
<h3 id="五-状态码"><a href="#五-状态码" class="headerlink" title="五 状态码"></a>五 状态码</h3><p><img src="https://user-gold-cdn.xitu.io/2018/5/8/1633e19dba27ed00?w=673&amp;h=218&amp;f=png&amp;s=72968" alt="状态码"></p>
<h3 id="六-各种协议与HTTP协议之间的关系"><a href="#六-各种协议与HTTP协议之间的关系" class="headerlink" title="六 各种协议与HTTP协议之间的关系"></a>六 各种协议与HTTP协议之间的关系</h3><p>一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。</p>
<p>图片来源：《图解HTTP》</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/8/1633ead316d07713?w=841&amp;h=1193&amp;f=png&amp;s=609513" alt="各种协议与HTTP协议之间的关系"></p>
<h3 id="七-HTTP长连接、短连接"><a href="#七-HTTP长连接、短连接" class="headerlink" title="七  HTTP长连接、短连接"></a>七  HTTP长连接、短连接</h3><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>
<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong> </p>
<p>—— <a href="https://www.cnblogs.com/gotodsp/p/6366163.html" target="_blank" rel="noopener">《HTTP长连接、短连接究竟是什么？》</a></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><h3 id="推荐一个自己的开源的后端文档"><a href="#推荐一个自己的开源的后端文档" class="headerlink" title="推荐一个自己的开源的后端文档"></a>推荐一个自己的开源的后端文档</h3><p>Java-Guide： Java面试通关手册（Java学习指南）Java Interview Customs Manual (Java Study Guide)。</p>
<p>👉Github地址：<a href="https://github.com/Snailclimb/Java-Guide" target="_blank" rel="noopener">https://github.com/Snailclimb/Java-Guide</a></p>
<p>👊文档定位：一个专门为Java后端工程师准备的开源文档，相信不论你是Java新手还是已经成为一名Java工程师都能从这份文档中收获到一些东西。</p>
<p>关于计算机网络基础知识大家可以查看（第一篇基础知识，第二篇偏总结，都很不错）：</p>
<ul>
<li><a href="https://github.com/Snailclimb/Java-Guide/blob/master/计算机网络与数据通信/干货：计算机网络知识总结.md" target="_blank" rel="noopener">《计算机网络知识总结》</a>。</li>
<li><a href="https://juejin.im/post/5ad7e6c35188252ebd06acfa" target="_blank" rel="noopener">面试带你飞：这是一份全面的 计算机网络基础 总结攻略</a></li>
</ul>
<h3 id="计算机网络常见问题回顾"><a href="#计算机网络常见问题回顾" class="headerlink" title="计算机网络常见问题回顾"></a>计算机网络常见问题回顾</h3><p>计算机网络最常见的问题我觉得应该是这5个了：</p>
<ul>
<li>①TCP三次握手和四次挥手、</li>
<li>②在浏览器中输入url地址-&gt;&gt;显示主页的过程</li>
<li>③HTTP和HTTPS的区别</li>
<li>④TCP、UDP协议的区别</li>
<li>⑤常见的状态码。 </li>
</ul>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>非常推荐大家看一下 《图解HTTP》 这本书，这本书页数不多，但是内容很是充实，不管是用来系统的掌握网络方面的一些知识还是说纯粹为了应付面试都有很大帮助。下面的一些文章只是参考。大二学习这门课程的时候，我们使用的教材是 《计算机网络第七版》（谢希仁编著），不推荐大家看这本教材，书非常厚而且知识偏理论，不确定大家能不能心平气和的读完。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-07-30T03:02:35.783Z"><a href="/2018/07/30/计算机网络与数据通信/数据通信(RESTful、RPC、消息队列)/">2018-07-30</a></time>
      
      
  
    <h1 class="title"><a href="/2018/07/30/计算机网络与数据通信/数据通信(RESTful、RPC、消息队列)/"></a></h1>
  

    </header>
    <div class="entry">
      
        <blockquote>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2></blockquote>
<p><strong>RPC（Remote Procedure Call）—远程过程调用</strong> ，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发分布式程序就像开发本地程序一样简单。</p>
<p><strong>RPC采用客户端（服务调用方）/服务器端（服务提供方）模式，</strong> 都运行在自己的JVM中。客户端只需要引入要使用的接口，接口的实现和运行都在服务器端。RPC主要依赖的技术包括序列化、反序列化和数据传输协议，这是一种定义与实现相分离的设计。</p>
<p><strong>目前Java使用比较多的RPC方案主要有RMI（JDK自带）、Hessian、Dubbo以及Thrift等。</strong></p>
<p><strong>注意： RPC主要指内部服务之间的调用，RESTful也可以用于内部服务之间的调用，但其主要用途还在于外部系统提供服务，因此没有将其包含在本知识点内。</strong></p>
<h3 id="常见RPC框架："><a href="#常见RPC框架：" class="headerlink" title="常见RPC框架："></a>常见RPC框架：</h3><ul>
<li><p><strong>RMI（JDK自带）：</strong> JDK自带的RPC</p>
<p> 详细内容可以参考：<a href="https://blog.csdn.net/lmy86263/article/details/72594760" target="_blank" rel="noopener">从懵逼到恍然大悟之Java中RMI的使用</a></p>
</li>
<li><p><strong>Dubbo:</strong> Dubbo是 阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。</p>
<p>详细内容可以参考：</p>
<ul>
<li><p><a href="https://blog.csdn.net/qq_34337272/article/details/79862899" target="_blank" rel="noopener"> 高性能优秀的服务框架-dubbo介绍</a></p>
</li>
<li><p><a href="https://blog.csdn.net/houshaolin/article/details/76408399" target="_blank" rel="noopener">Dubbo是什么？能做什么？</a></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>Hessian：</strong> Hessian是一个轻量级的remotingonhttp工具，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。</p>
<p>详细内容可以参考： <a href="https://blog.csdn.net/sunwei_pyw/article/details/74002351" target="_blank" rel="noopener">Hessian的使用以及理解</a></p>
</li>
<li><p><strong>Thrift：</strong>  Apache Thrift是Facebook开源的跨语言的RPC通信框架，目前已经捐献给Apache基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于thrift研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。</p>
</li>
</ul>
<pre><code>详细内容可以参考： [【Java】分布式RPC通信框架Apache Thrift 使用总结](https://www.cnblogs.com/zeze/p/8628585.html)
</code></pre><h3 id="如何进行选择："><a href="#如何进行选择：" class="headerlink" title="如何进行选择："></a>如何进行选择：</h3><ul>
<li><strong>是否允许代码侵入：</strong>  即需要依赖相应的代码生成器生成代码，比如Thrift。</li>
<li><strong>是否需要长连接获取高性能：</strong>  如果对于性能需求较高的haul，那么可以果断选择基于TCP的Thrift、Dubbo。</li>
<li><strong>是否需要跨越网段、跨越防火墙：</strong> 这种情况一般选择基于HTTP协议的Hessian和Thrift的HTTP Transport。</li>
</ul>
<p>此外，Google推出的基于HTTP2.0的gRPC框架也开始得到应用，其序列化协议基于Protobuf，网络框架使用的是Netty4,但是其需要生成代码，可扩展性也比较差。  </p>
<blockquote>
<h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2></blockquote>
<p><strong>消息中间件，也可以叫做中央消息队列或者是消息队列（区别于本地消息队列，本地消息队列指的是JVM内的队列实现）</strong>，是一种独立的队列系统，消息中间件经常用来解决内部服务之间的 <strong>异步调用问题</strong> 。请求服务方把请求队列放到队列中即可返回，然后等待服务提供方去队列中获取请求进行处理，之后通过回调等机制把结果返回给请求服务方。</p>
<p>异步调用只是消息中间件一个非常常见的应用场景。此外，常用的消息队列应用场景还偷如下几个：</p>
<ul>
<li><strong>解耦 ：</strong> 一个业务的非核心流程需要依赖其他系统，但结果并不重要，有通知即可。</li>
<li><strong>最终一致性 ：</strong> 指的是两个系统的状态保持一致，可以有一定的延迟，只要最终达到一致性即可。经常用在解决分布式事务上。</li>
<li><strong>广播 ：</strong> 消息队列最基本的功能。生产者只负责生产消息，订阅者接收消息。</li>
<li><strong>错峰和流控</strong></li>
</ul>
<p>具体可以参考： </p>
<p><a href="https://blog.csdn.net/qq_34337272/article/details/80029918" target="_blank" rel="noopener">《消息队列深入解析》</a></p>
<p>当前使用较多的消息队列有ActiveMQ（性能差，不推荐使用）、RabbitMQ、RocketMQ、Kafka等等，我们之前提高的redis数据库也可以实现消息队列，不过不推荐，redis本身设计就不是用来做消息队列的。</p>
<ul>
<li><p><strong>ActiveMQ：</strong> ActiveMQ是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ是一个完全支持JMS1.1和J2EE 1.4规范的JMSProvider实现,尽管JMS规范出台已经是很久的事情了,但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。</p>
<p>具体可以参考： </p>
<p><a href="https://blog.csdn.net/qq_34337272/article/details/80031702" target="_blank" rel="noopener">《消息队列ActiveMQ的使用详解》</a></p>
</li>
<li><p><strong>RabbitMQ:</strong> RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗</p>
<blockquote>
<p>AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。</p>
</blockquote>
</li>
</ul>
<p>   具体可以参考：</p>
<p>   <a href="https://www.jianshu.com/p/79ca08116d57" target="_blank" rel="noopener">《消息队列之 RabbitMQ》</a></p>
<ul>
<li><p><strong>RocketMQ：</strong></p>
<p> 具体可以参考：</p>
<p> <a href="https://www.jianshu.com/p/824066d70da8" target="_blank" rel="noopener">《RocketMQ 实战之快速入门》</a></p>
<p> <a href="http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/" target="_blank" rel="noopener">《十分钟入门RocketMQ》</a> （阿里中间件团队博客）</p>
</li>
</ul>
<ul>
<li><p><strong>Kafka</strong>：Kafka是一个分布式的、可分区的、可复制的、基于发布/订阅的消息系统,Kafka主要用于大数据领域,当然在分布式系统中也有应用。目前市面上流行的消息队列RocketMQ就是阿里借鉴Kafka的原理、用Java开发而得。</p>
<p>具体可以参考：</p>
<p><a href="http://book.51cto.com/art/201801/565244.htm" target="_blank" rel="noopener">《Kafka应用场景》</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484106&amp;idx=1&amp;sn=aa1999895d009d91eb3692a3e6429d18&amp;chksm=fd9854abcaefddbd1101ca5dc2c7c783d7171320d6300d9b2d8e68b7ef8abd2b02ea03e03600#rd" target="_blank" rel="noopener">《初谈Kafka》</a></p>
</li>
</ul>
<p><strong>推荐阅读：</strong></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU5OTMyODAyNg==&amp;mid=2247484721&amp;idx=1&amp;sn=11e4e29886e581dd328311d308ccc068&amp;chksm=feb7d144c9c058529465b02a4e26a25ef76b60be8984ace9e4a0f5d3d98ca52e014ecb73b061&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-07-30T03:02:35.783Z"><a href="/2018/07/30/计算机网络与数据通信/干货：计算机网络知识总结/">2018-07-30</a></time>
      
      
  
    <h1 class="title"><a href="/2018/07/30/计算机网络与数据通信/干货：计算机网络知识总结/"></a></h1>
  

    </header>
    <div class="entry">
      
        <blockquote>
<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1></blockquote>
<h3 id="1-计算机概述"><a href="#1-计算机概述" class="headerlink" title="1. 计算机概述 "></a>1. <a href="#一计算机概述">计算机概述 </a></h3><h3 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2. 物理层 "></a>2. <a href="#二物理层">物理层 </a></h3><h3 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3. 数据链路层 "></a>3. <a href="#三数据链路层">数据链路层 </a></h3><h3 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层 "></a>4. <a href="#四网络层">网络层 </a></h3><h3 id="5-运输层"><a href="#5-运输层" class="headerlink" title="5. 运输层 "></a>5. <a href="#五运输层">运输层 </a></h3><h3 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6. 应用层"></a>6. <a href="#六应用层">应用层</a></h3><h2 id="一计算机概述"><a href="#一计算机概述" class="headerlink" title="一计算机概述"></a>一计算机概述</h2><h3 id="（1），基本术语"><a href="#（1），基本术语" class="headerlink" title="（1），基本术语"></a><font color="#003333">（1），基本术语<font></font></font></h3><h4 id="结点-（node）："><a href="#结点-（node）：" class="headerlink" title="  结点 （node）："></a><font color="#99CC33">  结点 （node）：<font></font></font></h4><pre><code>网络中的结点可以是计算机，集线器，交换机或路由器等。
</code></pre><h4 id="链路（link-）："><a href="#链路（link-）：" class="headerlink" title="  链路（link  ）："></a><font color="#99CC33">  链路（link  ）：</font></h4><pre><code>从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。
</code></pre><h4 id="主机（host）："><a href="#主机（host）：" class="headerlink" title=" 主机（host）："></a><font color="#99CC33"> 主机（host）：</font></h4><pre><code>连接在因特网上的计算机.
</code></pre><h4 id="ISP（Internet-Service-Provider）："><a href="#ISP（Internet-Service-Provider）：" class="headerlink" title=" ISP（Internet Service Provider）："></a><font color="#99CC33"> ISP（Internet Service Provider）：</font></h4><pre><code>因特网服务提供者（提供商）.
</code></pre><h4 id="IXP（Internet-eXchange-Point）："><a href="#IXP（Internet-eXchange-Point）：" class="headerlink" title=" IXP（Internet eXchange Point）："></a><font color="#99CC33"> IXP（Internet eXchange Point）：</font></h4><pre><code>互联网交换点IXP的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。.
</code></pre><h4 id="RFC-Request-For-Comments"><a href="#RFC-Request-For-Comments" class="headerlink" title=" RFC(Request For Comments)"></a><font color="#99CC33"> RFC(Request For Comments)</font></h4><pre><code>意思是“请求评议”，包含了关于Internet几乎所有的重要的文字资料。
</code></pre><h4 id="广域网WAN（Wide-Area-Network）"><a href="#广域网WAN（Wide-Area-Network）" class="headerlink" title=" 广域网WAN（Wide Area Network）"></a><font color="#99CC33"> 广域网WAN（Wide Area Network）</font></h4><pre><code>任务是通过长距离运送主机发送的数据
</code></pre><h4 id="城域网MAN（Metropolitan-Area-Network）"><a href="#城域网MAN（Metropolitan-Area-Network）" class="headerlink" title=" 城域网MAN（Metropolitan Area Network）"></a><font color="#99CC33"> 城域网MAN（Metropolitan Area Network）</font></h4><pre><code>用来讲多个局域网进行互连
</code></pre><h4 id="局域网LAN（Local-Area-Network）"><a href="#局域网LAN（Local-Area-Network）" class="headerlink" title=" 局域网LAN（Local Area Network）"></a><font color="#99CC33"> 局域网LAN（Local Area Network）</font></h4><pre><code>学校或企业大多拥有多个互连的局域网
</code></pre><h4 id="个人区域网PAN（Personal-Area-Network）"><a href="#个人区域网PAN（Personal-Area-Network）" class="headerlink" title=" 个人区域网PAN（Personal Area Network）"></a><font color="#99CC33"> 个人区域网PAN（Personal Area Network）</font></h4><pre><code>在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络  
</code></pre><h4 id="端系统（end-system）："><a href="#端系统（end-system）：" class="headerlink" title="  端系统（end system）："></a><font color="#99CC33">  端系统（end system）：</font></h4><pre><code>处在因特网边缘的部分即是连接在因特网上的所有的主机.
</code></pre><h4 id="分组（packet-）："><a href="#分组（packet-）：" class="headerlink" title=" 分组（packet ）："></a><font color="#99CC33"> 分组（packet ）：</font></h4><pre><code>因特网中传送的数据单元。由首部header和数据段组成。分组又称为包，首部可称为包头。
</code></pre><h4 id="存储转发（store-and-forward-）"><a href="#存储转发（store-and-forward-）" class="headerlink" title=" 存储转发（store and forward ）:"></a><font color="#99CC33"> 存储转发（store and forward ）:</font></h4><pre><code>路由器收到一个分组，先存储下来，再检查气首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去。
</code></pre><h4 id="带宽（bandwidth）："><a href="#带宽（bandwidth）：" class="headerlink" title=" 带宽（bandwidth）："></a><font color="#99CC33"> 带宽（bandwidth）：</font></h4><pre><code>在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为b/s。
</code></pre><h4 id="吞吐量（throughput-）："><a href="#吞吐量（throughput-）：" class="headerlink" title=" 吞吐量（throughput ）："></a><font color="#99CC33"> 吞吐量（throughput ）：</font></h4><pre><code>表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。
</code></pre><h3 id="（2），重要知识点总结"><a href="#（2），重要知识点总结" class="headerlink" title="（2），重要知识点总结"></a><font color="#003333">（2），重要知识点总结<font></font></font></h3> <font color="#999999">1，计算机网络（简称网络）把许多计算机连接在一起，而互联网把许多网络连接在一起，是网络的网络。<br><br> <font color="#999999">2，小写字母i开头的internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。<br><br> <font color="#999999">大写字母I开头的Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用TCP/IP协议作为通信规则，其前身为ARPANET。Internet的推荐译名为因特网，现在一般流行称为互联网。<br><br> <font color="#999999">3，路由器是实现分组交换的关键构件，其任务是转发受到的分组，这是网络核心部分最重要的功能。分组交换采用存储转发技术，表示把一个报文（要发送的整块数据）分为几个分组后在进行传送。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每个数据端的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组。分组有称为包。分组是在互联网中传送的数据单元，正式由于分组的头部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立的选择传输路径，并正确地交付到分组传输的终点。<br><br><font color="#999999">4，互联网按工作方式可划分为边缘部分和核心部分。主机在网络的边缘部分，其作用是进行信息处理。由大量网络和连接这些网络的路由西组成边缘部分，其作用是提供连通性和交换。<br><br> <font color="#999999">5，计算机通信是计算机中进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式（C/S方式）和对等连接方式（P2P方式）。<br><br> <font color="#999999">6，客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。<br><br><font color="#999999">7，按照作用范围的不同，计算机网络分为广域网WAN，城域网MAN,局域网LAN，个人区域网PAN。<br><br> <font color="#999999">8，计算机网络最常用的性能指标是：速率，带宽，吞吐量，时延（发送时延，处理时延，排队时延），时延带宽积，往返时间和信道利用率。<br><br> <font color="#999999">9，网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。<br><br> <font color="#999999">10，五层体系结构由应用层，运输层，网络层（网际层），数据链路层，物理层组成。运输层最主要的协议是TCP和UDP协议，网络层最重要的协议是IP协议。<br><br>## 二物理层<br>### <font color="#003333">（1），基本术语<font><br>#### <font color="#99CC33">数据（data）：<font><br>    运送消息的实体。<br>#### <font color="#99CC33">信号（signal）：<font><br>    数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。<br>#### <font color="#99CC33">码元（ code）： <font><br>    在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。<br>#### <font color="#99CC33">单工（simplex ）：<font><br>    只能有一个方向的通信而没有反方向的交互。<br>#### <font color="#99CC33">半双工（half duplex ）：<font><br>    通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。<br>#### <font color="#99CC33">全双工（full duplex）： <font><br>    通信的双方可以同时发送和接收信息。<br>#### <font color="#99CC33">奈氏准则：<font><br>    在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。<br>#### <font color="#99CC33">基带信号（baseband signal）：<font><br>    来自信源的信号。指没有经过调制的数字信号或模拟信号。<br>#### <font color="#99CC33"> 带通（频带）信号（bandpass signal）：<font><br>    把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。<br>#### <font color="#99CC33"> 调制（modulation  ）：<font><br>    对信号源的信息进行处理后加到载波信号上，使其变为适合在信道传输的形式的过程。<br>#### <font color="#99CC33">信噪比（signal-to-noise ratio ）：<font><br>    指信号的平均功率和噪声的平均功率之比，记为S/N。信噪比（dB）=10*log10（S/N）<br>#### <font color="#99CC33">信道复用（channel multiplexing ）：<font><br>    指多个用户共享同一个信道。（并不一定是同时）<br>#### <font color="#99CC33">比特率（bit rate ）：<font><br>    单位时间（每秒）内传送的比特数。<br>#### <font color="#99CC33">波特率（baud rate）：<font><br>    单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。<br>#### <font color="#99CC33">复用（multiplexing）：<font><br>    共享信道的方法<br>#### <font color="#99CC33">ADSL（Asymmetric Digital Subscriber Line    ）： <font><br>    非对称数字用户线。<br>#### <font color="#99CC33">光纤同轴混合网（HFC网）:<font><br>    在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网<br><br>### <font color="#003333">（2），重要知识点总结<font><br><br> <font color="#999999">1，物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。</font>

 <font color="#999999">2，一个数据通信系统可划分为三大部分，即源系统，传输系统，目的系统。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。</font>

 <font color="#999999">3，通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电器或电磁的表现。</font>

 <font color="#999999">4，根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。在使用时间域（简称时域）的波形表示数字信号时，代表不同离散数值的基本波形称为码元。</font>

 <font color="#999999">5，根据双方信息交互的方式，通信可划分为单向通信（或单工通信），双向交替通信（或半双工通信），双向同时通信（全双工通信）。</font>

 <font color="#999999">6，来自信源的信号称为基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。</font>

 <font color="#999999">7，要提高数据在信道上的传递速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能任意被提高。</font>

 <font color="#999999">8，传输媒体可分为两大类，即导引型传输媒体（双绞线，同轴电缆，光纤）和非导引型传输媒体（无线，红外，大气激光）。</font>

 <font color="#999999">9，为了有效利用光纤资源，在光纤干线和用户之间广泛使用无源光网络PON。无源光网络无需配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络EPON和吉比特无源光网络GPON。</font>

<h3 id="（3），最重要的知识点"><a href="#（3），最重要的知识点" class="headerlink" title="（3），最重要的知识点"></a><font color="#003333">（3），最重要的知识点<font></font></font></h3><h4 id="①，物理层的任务"><a href="#①，物理层的任务" class="headerlink" title="①，物理层的任务"></a><font color="#003333"><strong>①，物理层的任务</strong><font></font></font></h4> <font color="#999999">透明地传送比特流。也可以将物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：机械特性（接口所用接线器的一些物理属性如形状尺寸），电气特性（接口电缆的各条线上出现的电压的范围），功能特性（某条线上出现的某一电平的电压的意义），过程特性（对于不同功能能的各种可能事件的出现顺序）。</font>

<h4 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h4> <font color="#999999">物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。</font>

<h4 id="②，几种常用的信道复用技术"><a href="#②，几种常用的信道复用技术" class="headerlink" title="②，几种常用的信道复用技术"></a><font color="#003333"><strong>②，几种常用的信道复用技术</strong><font></font></font></h4><p><img src="https://user-gold-cdn.xitu.io/2018/4/1/1627f7a170ec6611?w=1247&amp;h=425&amp;f=png&amp;s=36746" alt="这里写图片描述"></p>
<h3 id="③，几种常用的宽带接入技术，主要是ADSL和FTTx"><a href="#③，几种常用的宽带接入技术，主要是ADSL和FTTx" class="headerlink" title="③，几种常用的宽带接入技术，主要是ADSL和FTTx"></a><font color="#003333"><strong>③，几种常用的宽带接入技术，主要是ADSL和FTTx</strong><font></font></font></h3> <font color="#999999">用户到互联网的宽带接入方法有非对称数字用户线ADSL（用数字技术对现有的模拟电话线进行改造，而不需要重新布线。ASDL的快速版本是甚高速数字用户线VDSL。），光纤同轴混合网HFC（是在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网）和FTTx（即光纤到······）。</font>

<h2 id="三数据链路层"><a href="#三数据链路层" class="headerlink" title="三数据链路层"></a>三数据链路层</h2><h3 id="（1），基本术语-1"><a href="#（1），基本术语-1" class="headerlink" title="（1），基本术语"></a><font color="#003333">（1），基本术语<font></font></font></h3><h4 id="链路（link）："><a href="#链路（link）：" class="headerlink" title=" 链路（link）："></a><font color="#99CC33"> 链路（link）：<font></font></font></h4><pre><code>一个结点到相邻结点的一段物理链路
</code></pre><h4 id="数据链路（data-link）："><a href="#数据链路（data-link）：" class="headerlink" title=" 数据链路（data link）："></a><font color="#99CC33"> 数据链路（data link）：<font></font></font></h4><pre><code>把实现控制数据运输的协议的硬件和软件加到链路上就构成了数据链路
</code></pre><h4 id="循环冗余检验CRC（Cyclic-Redundancy-Check）："><a href="#循环冗余检验CRC（Cyclic-Redundancy-Check）：" class="headerlink" title=" 循环冗余检验CRC（Cyclic Redundancy Check）："></a><font color="#99CC33"> 循环冗余检验CRC（Cyclic Redundancy Check）：<font></font></font></h4><pre><code>为了保证数据传输的可靠性，CRC是数据链路层广泛使用的一种检错技术
</code></pre><h4 id="帧（frame）："><a href="#帧（frame）：" class="headerlink" title="  帧（frame）："></a><font color="#99CC33">  帧（frame）：<font></font></font></h4><pre><code>一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。
</code></pre><h4 id="MTU（Maximum-Transfer-Uint-）："><a href="#MTU（Maximum-Transfer-Uint-）：" class="headerlink" title=" MTU（Maximum Transfer Uint  ）："></a><font color="#99CC33"> MTU（Maximum Transfer Uint  ）：<font></font></font></h4><pre><code>最大传送单元。帧的数据部分的的长度上限。
</code></pre><h4 id="误码率BER（Bit-Error-Rate-）："><a href="#误码率BER（Bit-Error-Rate-）：" class="headerlink" title=" 误码率BER（Bit Error Rate ）："></a><font color="#99CC33"> 误码率BER（Bit Error Rate ）：<font></font></font></h4><pre><code>在一段时间内，传输错误的比特占所传输比特总数的比率。
</code></pre><h4 id="PPP（Point-to-Point-Protocol-）："><a href="#PPP（Point-to-Point-Protocol-）：" class="headerlink" title=" PPP（Point-to-Point Protocol  ）："></a><font color="#99CC33"> PPP（Point-to-Point Protocol  ）：<font></font></font></h4><pre><code>点对点协议。即用户计算机和ISP进行通信时所使用的数据链路层协议。以下是PPP帧的示意图:
</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/4/1/1627f8291c6b032c?w=624&amp;h=359&amp;f=jpeg&amp;s=44271" alt="PPP"></p>
<h4 id="MAC地址（Media-Access-Control或者Medium-Access-Control）："><a href="#MAC地址（Media-Access-Control或者Medium-Access-Control）：" class="headerlink" title=" MAC地址（Media Access Control或者Medium Access Control）："></a><font color="#99CC33"> MAC地址（Media Access Control或者Medium Access Control）：<font></font></font></h4><pre><code>意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。
在OSI模型中，第三层网络层负责 IP地址，第二层数据链路层则负责 MAC地址。
因此一个主机会有一个MAC地址，而每个网络位置会有一个专属于它的IP地址  。
地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处”
</code></pre><h4 id="网桥（bridge）："><a href="#网桥（bridge）：" class="headerlink" title=" 网桥（bridge）："></a><font color="#99CC33"> 网桥（bridge）：<font></font></font></h4><pre><code>一种用于数据链路层实现中继，连接两个或多个局域网的网络互连设备。
</code></pre><h4 id="交换机（switch-）："><a href="#交换机（switch-）：" class="headerlink" title=" 交换机（switch ）："></a><font color="#99CC33"> 交换机（switch ）：<font></font></font></h4><pre><code>广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥
</code></pre><h3 id="（2），重要知识点总结-1"><a href="#（2），重要知识点总结-1" class="headerlink" title="（2），重要知识点总结"></a><font color="#003333">（2），重要知识点总结<font></font></font></h3><font color="#999999">1，链路是从一个结点到相邻节点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</font>

<font color="#999999">2，数据链路层使用的主要是<strong>点对点信道</strong>和<strong>广播信道</strong>两种。</font>

<font color="#999999">3，数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong></font>

<font color="#999999">4，<strong>循环冗余检验CRC</strong>是一种检错方法，而帧检验序列FCS是添加在数据后面的冗余码</font>

<font color="#999999">5，<strong>点对点协议PPP</strong>是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议</font>

<font color="#999999"> 6，PPPoE是为宽带上网的主机使用的链路层协议</font>

<font color="#999999">7，局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。</font>

<font color="#999999">8，共向媒体通信资源的方法有二：一是静态划分信道(各种复用技术)，而是动态媒体接入控制，又称为多点接入（随即接入或受控接入）</font>

<font color="#999999">9，计算机与外接局域网通信需要通过通信适配器（或网络适配器），它又称为网络接口卡或网卡。<strong>计算器的硬件地址就在适配器的ROM中</strong>。</font>

<font color="#999999">10，以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做</font>

<font color="#999999">11，以太网采用的协议是具有冲突检测的<strong>载波监听多点接入CSMA/CD</strong>。协议的特点是：<strong>发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。</strong> 因此，每一个站点在自己发送数据之后的一小段时间内，存在这遭遇碰撞的可能性。以太网上的各站点平等的争用以太网信道</font>

<font color="#999999">12，以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。</font>

<font color="#999999">13，使用集线器可以在物理层扩展以太网（扩展后的以太网任然是一个网络）</font><br>### <font color="#003333">（3），最重要的知识点<font><br>#### ① <font color="#999999">数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议（PPP协议以及CSMA/CD协议）的特点<font><br>#### ② <font color="#999999">数据链路层的三个基本问题：<strong>封装成帧</strong>，<strong>透明传输</strong>，<strong>差错检测</strong><font><br>#### ③ <font color="#999999">以太网的MAC层硬件地址<font><br>#### ④ <font color="#999999">适配器，转发器，集线器，网桥，以太网交换机的作用以及适用场合<font><br><br>## <font color="#003333" id="4">四网络层<font><br>### <font color="#003333">（1），基本术语<font><br><br>#### <font color="#99CC33">虚电路（Virtual Circuit）：<font><br>    在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。<br>#### <font color="#99CC33">IP（Internet Protocol ）：<font><br>    网际协议 IP 是 TCP/IP体系中两个最主要的协议之一，是TCP/IP体系结构网际层的核心。配套的有ARP，RARP，ICMP，IGMP。<br> <img src="https://user-gold-cdn.xitu.io/2018/4/1/1627f92f98436286?w=453&amp;h=331&amp;f=jpeg&amp;s=27535" alt="这里写图片描述"><br>#### <font color="#99CC33">ARP（Address Resolution Protocol）：<font><br>    地址解析协议<br>#### <font color="#99CC33">ICMP（Internet Control Message Protocol ）：<font><br>    网际控制报文协议  （ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。）<br>#### <font color="#99CC33">子网掩码（subnet mask ）：<font><br>    它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。<br>#### <font color="#99CC33"> CIDR（ Classless Inter-Domain Routing ）：<font><br>    无分类域间路由选择  （特点是消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号）<br>#### <font color="#99CC33">默认路由（default route）：<font><br>    当在路由表中查不到能到达目的地址的路由时，路由器选择的路由。默认路由还可以减小路由表所占用的空间和搜索路由表所用的时间。<br>#### <font color="#99CC33">路由选择算法（Virtual Circuit）：<font><br>    路由选择协议的核心部分。因特网采用自适应的，分层次的路由选择协议。<br><br>### <font color="#003333">（2），重要知识点总结<font><br><font color="#999999">1，TCP/IP协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限所传送的分组可能出错，丢失，重复和失序。进程之间通信的可靠性由运输层负责</font>

<font color="#999999">2，在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付</font>

<font color="#999999">3，分类的IP地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别指明IP地址的类别。IP地址市一中分等级的地址结构。IP地址管理机构分配IP地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的IP地址</font>

<font color="#999999">4，IP数据报分为首部和数据两部分。首部的前一部分是固定长度，共20字节，是所有IP数据包必须具有的（源地址，目的地址，总长度等重要地段都固定在首部）。一些长度可变的可选字段固定在首部的后面。IP首部中的生存时间给出了IP数据报在互联网中所能经过的最大路由器数。可防止IP数据报在互联网中无限制的兜圈子。</font>

<font color="#999999">5，地址解析协议ARP把IP地址解析为硬件地址。ARP的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去广播方式发送ARP请求分组</font>

<font color="#999999">6，无分类域间路由选择CIDR是解决目前IP地址紧缺的一个好办法。CIDR记法把IP地址后面加上斜线“/”，然后写上前缀所所占的位数。前缀（或网络前缀用来指明网络），前缀后面的部分是后缀，用来指明主机。CIDR把前缀都相同的连续的IP地址组成一个“CIDR地址块”，IP地址分配都以CIDR地址块为单位。</font>

<font color="#999999">7， 网际控制报文协议是IP层的协议.ICMP报文作为IP数据报的数据，加上首部后组成IP数据报发送出去。使用ICMP数据报并不是为了实现可靠传输。ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP报文的种类有两种   ICMP差错报告报文和ICMP询问报文。</font>

<font color="#999999">8，要解决IP地址耗尽的问题，最根本的办法是采用具有更大地址弓箭的新版本IP协议-IPv6。IPv6所带来的变化有①更大的地址空间（采用128位地址）②灵活的首部格式③改进的选项④支持即插即用⑤支持资源的预分配⑥IPv6的首部改为8字节对齐。另外IP数据报的目的地址可以是以下三种基本类型地址之一：单播，多播和任播</font>

<font color="#999999">9，虚拟专用网络VPN利用公用的互联网作为本机构专用网之间的通信载体。VPN内使用互联网的专用地址。一个VPN至少要有一个路由器具有合法的全球IP地址，这样才能和本系统的另一个VPN通过互联网进行通信。所有通过互联网传送的数据都需要加密</font>

<font color="#999999">10， MPLS的特点是：①支持面向连接的服务质量②支持流量工程，平衡网络负载③有效的支持虚拟专用网VPN。MPLS在入口节点给每一个IP数据报打上固定长度的“标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记交换），因而转发速率大大加快。</font>

<h3 id="（3），最重要知识点"><a href="#（3），最重要知识点" class="headerlink" title="（3），最重要知识点"></a><font color="#003333">（3），最重要知识点<font></font></font></h3><h4 id="①-虚拟互联网络的概念"><a href="#①-虚拟互联网络的概念" class="headerlink" title="① 虚拟互联网络的概念"></a>① <font color="#999999">虚拟互联网络的概念</font></h4><h4 id="②-IP地址和物理地址的关系"><a href="#②-IP地址和物理地址的关系" class="headerlink" title="② IP地址和物理地址的关系"></a>② <font color="#999999">IP地址和物理地址的关系</font></h4><h4 id="③-传统的分类的IP地址（包括子网掩码）和误分类域间路由选择CIDR"><a href="#③-传统的分类的IP地址（包括子网掩码）和误分类域间路由选择CIDR" class="headerlink" title="③  传统的分类的IP地址（包括子网掩码）和误分类域间路由选择CIDR"></a>③ <font color="#999999"> 传统的分类的IP地址（包括子网掩码）和误分类域间路由选择CIDR</font></h4><h4 id="④-路由选择协议的工作原理"><a href="#④-路由选择协议的工作原理" class="headerlink" title="④   路由选择协议的工作原理"></a>④ <font color="#999999">  路由选择协议的工作原理</font></h4><h2 id="五运输层"><a href="#五运输层" class="headerlink" title="五运输层"></a><font color="#003333" id="5">五运输层<font></font></font></h2><h3 id="（1），基本术语-2"><a href="#（1），基本术语-2" class="headerlink" title="（1），基本术语"></a><font color="#003333">（1），基本术语<font></font></font></h3><h4 id="进程（process）："><a href="#进程（process）：" class="headerlink" title="进程（process）："></a><font color="#99CC33">进程（process）：<font></font></font></h4><pre><code>指计算机中正在运行的程序实体
</code></pre><h4 id="应用进程互相通信："><a href="#应用进程互相通信：" class="headerlink" title="应用进程互相通信："></a><font color="#99CC33">应用进程互相通信：<font></font></font></h4><pre><code>一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信）
</code></pre><h4 id="传输层的复用与分用："><a href="#传输层的复用与分用：" class="headerlink" title="传输层的复用与分用："></a><font color="#99CC33">传输层的复用与分用：<font></font></font></h4><pre><code>复用指发送方不同的进程都可以通过统一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。 
</code></pre><h4 id="TCP（Transmission-Control-Protocol）："><a href="#TCP（Transmission-Control-Protocol）：" class="headerlink" title="TCP（Transmission Control Protocol）："></a><font color="#99CC33">TCP（Transmission Control Protocol）：<font></font></font></h4><pre><code>传输控制协议
</code></pre><h4 id="UDP（User-Datagram-Protocol）："><a href="#UDP（User-Datagram-Protocol）：" class="headerlink" title="UDP（User Datagram Protocol）："></a><font color="#99CC33">UDP（User Datagram Protocol）：<font></font></font></h4><pre><code>用户数据报协议
</code></pre><h4 id="端口（port）（link）："><a href="#端口（port）（link）：" class="headerlink" title="端口（port）（link）："></a><font color="#99CC33">端口（port）（link）：<font></font></font></h4><pre><code>端口的目的是为了确认对方机器是那个进程在于自己进行交互，比如MSN和QQ的端口不同，如果没有端口就可能出现QQ进程和MSN交互错误。端口又称协议端口号。 
</code></pre><h4 id="停止等待协议（link）："><a href="#停止等待协议（link）：" class="headerlink" title="停止等待协议（link）："></a><font color="#99CC33">停止等待协议（link）：<font></font></font></h4><pre><code>指发送方每发送完一个分组就停止发送，等待对方确认，在收到确认之后在发送下一个分组。
</code></pre><h4 id="流量控制（link）："><a href="#流量控制（link）：" class="headerlink" title="流量控制（link）："></a><font color="#99CC33">流量控制（link）：<font></font></font></h4><pre><code>就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。
</code></pre><h4 id="拥塞控制（link）："><a href="#拥塞控制（link）：" class="headerlink" title="拥塞控制（link）："></a><font color="#99CC33">拥塞控制（link）：<font></font></font></h4><pre><code>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。
</code></pre><h3 id="（2），重要知识点总结-2"><a href="#（2），重要知识点总结-2" class="headerlink" title="（2），重要知识点总结"></a><font color="#003333">（2），重要知识点总结<font></font></font></h3><p><font color="#999999">1，运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传输数据。运输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个运输层实体之间有一条端到端的逻辑通信信道。</font></p>
<p>2，网络层为主机提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</p>
<p>3，运输层的两个重要协议是用户数据报协议UDP和传输控制协议TCP。按照OSI的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元TPDU（Transport Protocol Data Unit）。但在TCP/IP体系中，则根据所使用的协议是TCP或UDP，分别称之为TCP报文段或UDP用户数据报。</p>
<p>4，UDP在传送数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP确是一种最有效的工作方式。 TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的，面向连接的运输服务，这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</p>
<p>5，硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP和TCP的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到IP层交上来的运输层报文时，就能够 根据其首部中的目的端口号把数据交付应用层的目的应用层。（两个进程之间进行通信不光要知道对方IP地址而且要知道对方的端口号(为了找到对方计算机中的应用进程)）</p>
<p>6，运输层用一个16位端口号标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由TCP和UDP来完成。</p>
<p>7，运输层的端口号分为服务器端使用的端口号（0~1023指派给熟知端口，1024~49151是登记端口号）和客户端暂时使用的端口号（49152~65535）</p>
<p>8，UDP的主要特点是①无连接②尽最大努力交付③面向报文④无拥塞控制⑤支持一对一，一对多，多对一和多对多的交互通信⑥首部开销小（只有四个字段：源端口，目的端口，长度和检验和）</p>
<p>9，TCP的主要特点是①面向连接②每一条TCP连接只能是一对一的③提供可靠交付④提供全双工通信⑤面向字节流</p>
<p>10，TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP地址：端口号）来表示。每一条TCP连接唯一被通信两端的两个端点所确定。</p>
<p> 11，停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p>
<p>12，为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。</p>
<p>13，停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续ARQ协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>
<p>14，TCP报文段的前20个字节是固定的，后面有4n字节是根据需要增加的选项。因此，TCP首部的最小长度是20字节。</p>
<p>15，TCP使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不晕与发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<p>16，在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>17，为了进行拥塞控制，TCP发送方要维持一个拥塞窗口cwnd的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>18，TCP的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理AQM），以减少网络拥塞的发生。</p>
<p>19，运输连接的三个阶段，即：连接建立，数据传送和连接释放。</p>
<p>20，主动发起TCP连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP连接采用三报文握手机制。服务器要确认用户的连接请求，然后客户要对服务器的确认进行确认。</p>
<p>21，TCP的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了TCP连接</p>
<h3 id="（3），最重要的知识点-1"><a href="#（3），最重要的知识点-1" class="headerlink" title="（3），最重要的知识点"></a><font color="#003333">（3），最重要的知识点<font></font></font></h3><h4 id="①-端口和套接字的意义"><a href="#①-端口和套接字的意义" class="headerlink" title="① 端口和套接字的意义"></a>① <font color="#999999">端口和套接字的意义<font></font></font></h4><h4 id="②-无连接UDP的特点"><a href="#②-无连接UDP的特点" class="headerlink" title="② 无连接UDP的特点"></a>② <font color="#999999">无连接UDP的特点<font></font></font></h4><h4 id="③-面向连接TCP的特点"><a href="#③-面向连接TCP的特点" class="headerlink" title="③ 面向连接TCP的特点"></a>③ <font color="#999999">面向连接TCP的特点<font></font></font></h4><h4 id="④-在不可靠的网络上实现可靠传输的工作原理，停止等待协议和ARQ协议"><a href="#④-在不可靠的网络上实现可靠传输的工作原理，停止等待协议和ARQ协议" class="headerlink" title="④ 在不可靠的网络上实现可靠传输的工作原理，停止等待协议和ARQ协议"></a>④ <font color="#999999">在不可靠的网络上实现可靠传输的工作原理，停止等待协议和ARQ协议<font></font></font></h4><h4 id="①-TCP的滑动窗口，流量控制，拥塞控制和连接管理"><a href="#①-TCP的滑动窗口，流量控制，拥塞控制和连接管理" class="headerlink" title="① TCP的滑动窗口，流量控制，拥塞控制和连接管理"></a>① <font color="#999999">TCP的滑动窗口，流量控制，拥塞控制和连接管理<font></font></font></h4><h2 id="六应用层"><a href="#六应用层" class="headerlink" title="六应用层"></a><font color="#003333" id="6">六应用层<font></font></font></h2><h3 id="（1），基本术语-3"><a href="#（1），基本术语-3" class="headerlink" title="（1），基本术语"></a><font color="#003333">（1），基本术语<font></font></font></h3><h4 id="域名系统（DNS）："><a href="#域名系统（DNS）：" class="headerlink" title="  域名系统（DNS）："></a><font color="#99CC33">  域名系统（DNS）：<font></font></font></h4><pre><code>DNS（Domain Name System，域名系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。
通过域名，最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。在RFC文档中RFC 2181对DNS有规范说明，RFC 2136对DNS的动态更新进行说明，RFC 2308对DNS查询的反向缓存进行说明。
</code></pre><h4 id="文件传输协议（FTP）："><a href="#文件传输协议（FTP）：" class="headerlink" title=" 文件传输协议（FTP）："></a><font color="#99CC33"> 文件传输协议（FTP）：<font></font></font></h4><pre><code>FTP 是File TransferProtocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。
基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在FTP的使用当中，用户经常遇到两个概念：&quot;下载&quot;（Download）和&quot;上传&quot;（Upload）。
&quot;下载&quot;文件就是从远程主机拷贝文件至自己的计算机上；&quot;上传&quot;文件就是将文件从自己的计算机中拷贝至远程主机上。用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。
</code></pre><h4 id="简单文件传输协议（TFTP）："><a href="#简单文件传输协议（TFTP）：" class="headerlink" title=" 简单文件传输协议（TFTP）："></a><font color="#99CC33"> 简单文件传输协议（TFTP）：<font></font></font></h4><pre><code>TFTP（Trivial File Transfer Protocol,简单文件传输协议）是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。
</code></pre><h4 id="远程终端协议（TELENET）："><a href="#远程终端协议（TELENET）：" class="headerlink" title=" 远程终端协议（TELENET）："></a><font color="#99CC33"> 远程终端协议（TELENET）：<font></font></font></h4><pre><code>Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。
在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。
可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。
</code></pre><h4 id="万维网（WWW）："><a href="#万维网（WWW）：" class="headerlink" title=" 万维网（WWW）："></a><font color="#99CC33"> 万维网（WWW）：<font></font></font></h4><pre><code>WWW是环球信息网的缩写，（亦作“Web”、“WWW”、“&apos;W3&apos;”，英文全称为“World Wide Web”），中文名字为“万维网”，&quot;环球网&quot;等，常简称为Web。分为Web客户端和Web服务器程序。
WWW可以让Web客户端（常用浏览器）访问浏览Web服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。
万维网联盟（英语：World Wide Web Consortium，简称W3C），又称W3C理事会。1994年10月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。
万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。
</code></pre><h4 id="万维网的大致工作工程："><a href="#万维网的大致工作工程：" class="headerlink" title=" 万维网的大致工作工程："></a><font color="#99CC33"> 万维网的大致工作工程：<font></font></font></h4><p><img src="https://user-gold-cdn.xitu.io/2018/4/1/1627ff96a96087af?w=839&amp;h=610&amp;f=jpeg&amp;s=86703" alt="万维网的大致工作工程"></p>
<h4 id="统一资源定位符（URL）："><a href="#统一资源定位符（URL）：" class="headerlink" title=" 统一资源定位符（URL）："></a><font color="#99CC33"> 统一资源定位符（URL）：<font></font></font></h4><pre><code>统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 
</code></pre><h4 id="超文本传输协议（HTTP）："><a href="#超文本传输协议（HTTP）：" class="headerlink" title=" 超文本传输协议（HTTP）："></a><font color="#99CC33"> 超文本传输协议（HTTP）：<font></font></font></h4><pre><code>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。
设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。
</code></pre><h4 id="代理服务器（Proxy-Server）："><a href="#代理服务器（Proxy-Server）：" class="headerlink" title=" 代理服务器（Proxy Server）："></a><font color="#99CC33"> 代理服务器（Proxy Server）：<font></font></font></h4><pre><code>代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。
代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按URL的地址再次去互联网访问该资源。
代理服务器可在客户端或服务器工作，也可以在中间系统工作。 
</code></pre><h4 id="http请求头："><a href="#http请求头：" class="headerlink" title=" http请求头："></a><font color="#99CC33"> http请求头：<font></font></font></h4><pre><code>http请求头，HTTP客户程序（例如浏览器），向服务器发送请求的时候必须指明请求类型（一般是GET或者POST）。如有必要，客户程序还可以选择发送其他的请求头。
- Accept：浏览器可接受的MIME类型。
- Accept-Charset：浏览器可接受的字符集。
- Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。
- Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。
- Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。
- Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。
- Content-Length：表示请求消息正文的长度。
- Cookie：这是最重要的请求头信息之一
- From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。
- Host：初始URL中的主机和端口。
- If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。
- Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。
- Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。
- User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。
</code></pre><h4 id="简单邮件传输协议-SMTP-："><a href="#简单邮件传输协议-SMTP-：" class="headerlink" title="简单邮件传输协议(SMTP)："></a><font color="#99CC33">简单邮件传输协议(SMTP)：<font></font></font></h4><pre><code>SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。
SMTP协议属于TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。
通过SMTP协议所指定的服务器,就可以把E-mail寄到收信人的服务器上了，整个过程只要几分钟。SMTP服务器则是遵循SMTP协议的发送邮件服务器，用来发送或中转发出的电子邮件。
</code></pre><h4 id="搜索引擎："><a href="#搜索引擎：" class="headerlink" title="搜索引擎："></a><font color="#99CC33">搜索引擎：<font></font></font></h4><pre><code>搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。
搜索引擎包括全文索引、目录索引、元搜索引擎、垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。
</code></pre><h4 id="全文索引："><a href="#全文索引：" class="headerlink" title="全文索引："></a><font color="#99CC33">全文索引：<font></font></font></h4><pre><code> 全文索引技术是目前搜索引擎的关键技术。
试想在1M大小的文件中搜索一个词，可能需要几秒，在100M的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。
所以在这样的矛盾下出现了全文索引技术，有时候有人叫倒排文档技术。
</code></pre><h4 id="目录索引："><a href="#目录索引：" class="headerlink" title="目录索引："></a><font color="#99CC33">目录索引：<font></font></font></h4><pre><code>目录索引（ search index/directory)，顾名思义就是将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。
</code></pre><h4 id="垂直搜索引擎："><a href="#垂直搜索引擎：" class="headerlink" title="垂直搜索引擎："></a><font color="#99CC33">垂直搜索引擎：<font></font></font></h4><pre><code>垂直搜索引擎是针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。
垂直搜索是相对通用搜索引擎的信息量大、查询不准确、深度不够等提出来的新的搜索引擎服务模式，通过针对某一特定领域、某一特定人群或某一特定需求提供的有一定价值的信息和相关服务。
其特点就是“专、精、深”，且具有行业色彩，相比较通用搜索引擎的海量信息无序化，垂直搜索引擎则显得更加专注、具体和深入。
</code></pre><h3 id="（2），重要知识点总结-3"><a href="#（2），重要知识点总结-3" class="headerlink" title="（2），重要知识点总结"></a><font color="#003333">（2），重要知识点总结<font></font></font></h3><p><font color="#999999">1，文件传输协议（FTP）使用TCP可靠的运输服务。FTP使用客户服务器方式。一个FTP服务器进程可以同时为多个用户提供服务。在进进行文件传输时，FTP的客户和服务器之间要先建立两个并行的TCP连接:控制连接和数据连接。实际用于传输文件的是数据连接。</font></p>
<p><font color="#999999">2，万维网客户程序与服务器之间进行交互使用的协议时超文本传输协议HTTP。HTTP使用TCP连接进行可靠传输。但HTTP本身是无连接、无状态的。HTTP/1.1协议使用了持续连接（分为非流水线方式和流水线方式）</font></p>
<p><font color="#999999">3，电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器读取，相当于电子邮箱。</font></p>
<p><font color="#999999">4，一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如SMTP，和邮件读取协议，如POP3和IMAP）。用户代理和邮件服务器都要运行这些协议。</font></p>
<h3 id="（3），最重要知识点总结"><a href="#（3），最重要知识点总结" class="headerlink" title="（3），最重要知识点总结"></a><font color="#003333">（3），最重要知识点总结<font></font></font></h3><h4 id="①-域名系统-从域名解析出IP地址"><a href="#①-域名系统-从域名解析出IP地址" class="headerlink" title="① 域名系统-从域名解析出IP地址"></a>① <font color="#999999">域名系统-从域名解析出IP地址<font></font></font></h4><h4 id="②-访问一个网站大致的过程"><a href="#②-访问一个网站大致的过程" class="headerlink" title="② 访问一个网站大致的过程"></a>② <font color="#999999">访问一个网站大致的过程<font></font></font></h4><h4 id="③-系统调用和应用编程接口概念"><a href="#③-系统调用和应用编程接口概念" class="headerlink" title="③ 系统调用和应用编程接口概念"></a>③ <font color="#999999">系统调用和应用编程接口概念<font></font></font></h4></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-07-30T03:02:35.783Z"><a href="/2018/07/30/操作系统/后端程序员必备的Linux基础知识/">2018-07-30</a></time>
      
      
  
    <h1 class="title"><a href="/2018/07/30/操作系统/后端程序员必备的Linux基础知识/"></a></h1>
  

    </header>
    <div class="entry">
      
        <blockquote>
<p>学习Linux之前，我们先来简单的认识一下操作系统。</p>
</blockquote>
<h2 id="一-从认识操作系统开始"><a href="#一-从认识操作系统开始" class="headerlink" title="一 从认识操作系统开始"></a>一 从认识操作系统开始</h2><h3 id="1-1-操作系统简介"><a href="#1-1-操作系统简介" class="headerlink" title="1.1  操作系统简介"></a>1.1  操作系统简介</h3><p>我通过以下四点介绍什么操作系统：</p>
<ul>
<li><strong>操作系统（Operation System，简称OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石；</strong></li>
<li><strong>操作系统本质上是运行在计算机上的软件程序 ；</strong></li>
<li><strong>为用户提供一个与系统交互的操作界面 ；</strong></li>
<li><strong>操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。</strong></li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/3/1645ee3dc5cf626e?w=862&amp;h=637&amp;f=png&amp;s=23899" alt="操作系统分内核与外壳"></p>
<h3 id="1-2-操作系统简单分类"><a href="#1-2-操作系统简单分类" class="headerlink" title="1.2  操作系统简单分类"></a>1.2  操作系统简单分类</h3><ol>
<li><strong>Windows:</strong> 目前最流行的个人桌面操作系统 ，不做多的介绍，大家都清楚。</li>
<li><strong>Unix：</strong> 最早的多用户、多任务操作系统 .按照操作系统的分类，属于分时操作系统。Unix 大多被用在服务器、工作站，现在也有用在个人计算机上。它在创建互联网、计算机网络或客户端/服务器模型方面发挥着非常重要的作用。<br><img src="https://user-gold-cdn.xitu.io/2018/7/3/1645ee83f036846d?w=1075&amp;h=475&amp;f=png&amp;s=914462" alt="Unix"></li>
<li><strong>Linux:</strong> Linux是一套免费使用和自由传播的类Unix操作系统.Linux存在着许多不同的Linux版本，但它们都使用了 <strong>Linux内核</strong> 。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。严格来讲，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/3/1645eeb8e843f29d?w=426&amp;h=240&amp;f=png&amp;s=32650" alt="Linux"></p>
<h2 id="二-初探Linux"><a href="#二-初探Linux" class="headerlink" title="二  初探Linux"></a>二  初探Linux</h2><h3 id="2-1-Linux简介"><a href="#2-1-Linux简介" class="headerlink" title="2.1 Linux简介"></a>2.1 Linux简介</h3><p>我们上面已经介绍到了Linux，我们这里只强调三点。</p>
<ul>
<li><strong>类Unix系统：</strong> Linux是一种自由、开放源码的类似Unix的操作系统 </li>
<li><strong>Linux内核：</strong> 严格来说，Linux这个词本身只表示Linux内核 </li>
<li><strong>Linux之父：</strong> 一个编程领域的传奇式人物。他是Linux内核的最早作者，随后发起了这个开源项目，担任Linux内核的首要架构师与项目协调者，是当今世界最著名的电脑程序员、黑客之一。他还发起了Git这个开源项目，并为主要的开发者。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/3/1645ef0a5a4f137f?w=270&amp;h=376&amp;f=png&amp;s=193487" alt="Linux"></p>
<h3 id="2-2-Linux诞生简介"><a href="#2-2-Linux诞生简介" class="headerlink" title="2.2  Linux诞生简介"></a>2.2  Linux诞生简介</h3><ul>
<li>1991年，芬兰的业余计算机爱好者Linus Torvalds编写了一款类似Minix的系统（基于微内核架构的类Unix操作系统）被ftp管理员命名为Linux 加入到自由软件基金的GNU计划中; </li>
<li>Linux以一只可爱的企鹅作为标志，象征着敢作敢为、热爱生活。 </li>
</ul>
<h3 id="2-3-Linux的分类"><a href="#2-3-Linux的分类" class="headerlink" title="2.3 Linux的分类"></a>2.3 Linux的分类</h3><p><strong>Linux根据原生程度，分为两种：</strong></p>
<ol>
<li><strong>内核版本：</strong> Linux不是一个操作系统，严格来讲，Linux只是一个操作系统中的内核。内核是什么？内核建立了计算机软件与硬件之间通讯的平台，内核提供系统服务，比如文件管理、虚拟内存、设备I/O等；</li>
<li><strong>发行版本：</strong> 一些组织或公司在内核版基础上进行二次开发而重新发行的版本。Linux发行版本有很多种（ubuntu和CentOS用的都很多，初学建议选择CentOS），如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/7/3/1645efa7048fd018?w=548&amp;h=274&amp;f=png&amp;s=99213" alt="Linux发行版本"></li>
</ol>
<h2 id="三-Linux文件系统概览"><a href="#三-Linux文件系统概览" class="headerlink" title="三  Linux文件系统概览"></a>三  Linux文件系统概览</h2><h3 id="3-1-Linux文件系统简介"><a href="#3-1-Linux文件系统简介" class="headerlink" title="3.1 Linux文件系统简介"></a>3.1 Linux文件系统简介</h3><p><strong>在Linux操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong></p>
<p>也就是说在LINUX系统中有一个重要的概念：<strong>一切都是文件</strong>。其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来，所以这个概念也就传承了下来。在UNIX系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。</p>
<h3 id="3-2-文件类型与目录结构"><a href="#3-2-文件类型与目录结构" class="headerlink" title="3.2 文件类型与目录结构"></a>3.2 文件类型与目录结构</h3><p><strong>Linux支持5种文件类型 ：</strong><br><img src="https://user-gold-cdn.xitu.io/2018/7/3/1645f1a7d64def1a?w=901&amp;h=547&amp;f=png&amp;s=72692" alt="文件类型"></p>
<p><strong>Linux的目录结构如下：</strong></p>
<p>Linux文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：<br><img src="https://user-gold-cdn.xitu.io/2018/7/3/1645f1c65676caf6?w=823&amp;h=315&amp;f=png&amp;s=15226" alt="Linux的目录结构"></p>
<p><strong>常见目录说明：</strong></p>
<ul>
<li><strong>/bin：</strong> 存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里；</li>
<li><strong>/etc：</strong>  存放系统管理和配置文件；</li>
<li><strong>/home：</strong>  存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示；</li>
<li><strong>/usr ：</strong> 用于存放系统应用程序；</li>
<li><strong>/opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；</li>
<li><strong>/proc：</strong>  虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li>
<li><strong>/root：</strong>    超级用户（系统管理员）的主目录（特权阶级^o^）；</li>
<li><strong>/sbin:</strong>    存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；</li>
<li><strong>/dev：</strong>    用于存放设备文件；</li>
<li><strong>/mnt：</strong>    系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li>
<li><strong>/boot：</strong>    存放用于系统引导时使用的各种文件；</li>
<li><strong>/lib ：</strong>      存放着和系统运行相关的库文件 ；</li>
<li><strong>/tmp：</strong>    用于存放各种临时文件，是公用的临时文件存储点；</li>
<li><strong>/var：</strong>    用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li>
<li><strong>/lost+found：</strong>    这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。</li>
</ul>
<h2 id="四-Linux基本命令"><a href="#四-Linux基本命令" class="headerlink" title="四  Linux基本命令"></a>四  Linux基本命令</h2><p>下面只是给出了一些比较常用的命令。推荐一个Linux命令快查网站，非常不错，大家如果遗忘某些命令或者对某些命令不理解都可以在这里得到解决。</p>
<p>Linux命令大全：<a href="http://man.linuxde.net/" target="_blank" rel="noopener">http://man.linuxde.net/</a></p>
<h3 id="4-1-目录切换命令"><a href="#4-1-目录切换命令" class="headerlink" title="4.1 目录切换命令"></a>4.1 目录切换命令</h3><ul>
<li><strong><code>cd usr</code>：</strong>        切换到该目录下usr目录     </li>
<li><strong><code>cd ..（或cd../）</code>：</strong>    切换到上一层目录 </li>
<li><strong><code>cd /</code>：</strong>        切换到系统根目录     </li>
<li><strong><code>cd ~</code>：</strong>        切换到用户主目录 </li>
<li><strong><code>cd -</code>：</strong>        切换到上一个所在目录</li>
</ul>
<h3 id="4-2-目录的操作命令（增删改查）"><a href="#4-2-目录的操作命令（增删改查）" class="headerlink" title="4.2 目录的操作命令（增删改查）"></a>4.2 目录的操作命令（增删改查）</h3><ol>
<li><strong><code>mkdir 目录名称</code>：</strong> 增加目录</li>
<li><strong><code>ls或者ll</code></strong>（ll是ls -l的缩写，ll命令以看到该目录下的所有目录和文件的详细信息）：查看目录信息</li>
<li><p><strong><code>find 目录 参数</code>：</strong> 寻找目录（查）</p>
<p> 示例：</p>
<ul>
<li>列出当前目录及子目录下所有文件和文件夹: <code>find .</code></li>
<li>在<code>/home</code>目录下查找以.txt结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code></li>
<li>同上，但忽略大小写: <code>find /home -iname &quot;*.txt&quot;</code></li>
<li>当前目录及子目录下查找所有以.txt和.pdf结尾的文件:<code>find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</code>或<code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</code></li>
</ul>
</li>
<li><p><strong><code>mv 目录名称 新目录名称</code>：</strong> 修改目录的名称（改）</p>
<p>注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行    重命名的操作。mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到mv命令的另一个用法。</p>
</li>
<li><p><strong><code>mv 目录名称 目录的新位置</code>：</strong>  移动目录的位置—剪切（改）</p>
<p> 注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。</p>
</li>
<li><p><strong><code>cp -r 目录名称 目录拷贝的目标位置</code>：</strong> 拷贝目录（改），-r代表递归拷贝 </p>
<p> 注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不    用写-r递归</p>
</li>
<li><p><strong><code>rm [-rf] 目录</code>:</strong> 删除目录（删）</p>
<p> 注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆，    无论删除任何目录或文件，都直接使用<code>rm -rf</code> 目录/文件/压缩包</p>
</li>
</ol>
<h3 id="4-3-文件的操作命令（增删改查）"><a href="#4-3-文件的操作命令（增删改查）" class="headerlink" title="4.3 文件的操作命令（增删改查）"></a>4.3 文件的操作命令（增删改查）</h3><ol>
<li><strong><code>touch 文件名称</code>:</strong>  文件的创建（增）</li>
<li><p><strong><code>cat/more/less/tail 文件名称</code></strong> 文件的查看（查）</p>
<ul>
<li><strong><code>cat</code>：</strong> 只能显示最后一屏内容</li>
<li><strong><code>more</code>：</strong> 可以显示百分比，回车可以向下一行，    空格可以向下一页，q可以退出查看</li>
<li><strong><code>less</code>：</strong> 可以使用键盘上的PgUp和PgDn向上    和向下翻页，q结束查看</li>
<li><strong><code>tail-10</code> ：</strong> 查看文件的后10行，Ctrl+C结束</li>
</ul>
<p>注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件，    会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控    文    件的变化 </p>
</li>
<li><p><strong><code>vim 文件</code>：</strong>  修改文件的内容（改）</p>
<p>vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。</p>
<p><strong>在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤：</strong></p>
<p> vim 文件——&gt;进入文件—–&gt;命令模式——&gt;按i进入编辑模式—–&gt;编辑文件    ——-&gt;按Esc进入底行模式—–&gt;输入:wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）</p>
</li>
<li><p><strong><code>rm -rf 文件</code>：</strong> 删除文件（删）</p>
<p> 同目录删除：熟记 <code>rm -rf</code> 文件 即可</p>
</li>
</ol>
<h3 id="4-4-压缩文件的操作命令"><a href="#4-4-压缩文件的操作命令" class="headerlink" title="4.4 压缩文件的操作命令"></a>4.4 压缩文件的操作命令</h3><p><strong>1）打包并压缩文件：</strong></p>
<p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。</p>
<p>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。<br>命令：<strong><code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code></strong><br>其中：</p>
<p>  z：调用gzip压缩命令进行压缩</p>
<p>  c：打包文件</p>
<p>  v：显示运行过程</p>
<p>  f：指定文件名</p>
<p>比如：加入test目录下有三个文件分别是 :aaa.txt bbb.txt ccc.txt,如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令：<strong><code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code>或：<code>tar -zcvf test.tar.gz       /test/</code></strong></p>
<p><strong>2）解压压缩包：</strong></p>
<p>命令：tar [-xvf] 压缩文件</p>
<p>其中：x：代表解压</p>
<p>示例：</p>
<p>1 将/test下的test.tar.gz解压到当前目录下可以使用命令：<strong><code>tar -xvf test.tar.gz</code></strong></p>
<p>2 将/test下的test.tar.gz解压到根目录/usr下:<strong><code>tar -xvf xxx.tar.gz -C /usr</code></strong>（- C代表指定解压的位置）</p>
<h3 id="4-5-Linux的权限命令"><a href="#4-5-Linux的权限命令" class="headerlink" title="4.5 Linux的权限命令"></a>4.5 Linux的权限命令</h3><p> 操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在Linux中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。通过 <strong><code>ls -l</code></strong> 命令我们可以    查看某个目录下的文件或目录的权限</p>
<p>示例：在随意某个目录下<code>ls -l</code></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/5/1646955be781daaa?w=589&amp;h=228&amp;f=png&amp;s=16360" alt=""></p>
<p>第一列的内容的信息解释如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/5/16469565b6951791?w=489&amp;h=209&amp;f=png&amp;s=39791" alt=""></p>
<blockquote>
<p>下面将详细讲解文件的类型、Linux中权限以及文件有所有者、所在组、其它组具体是什么？</p>
</blockquote>
<p><strong>文件的类型：</strong></p>
<ul>
<li>d： 代表目录</li>
<li>-： 代表文件</li>
<li>l： 代表链接（可以认为是window中的快捷方式）</li>
</ul>
<p><strong>Linux中权限分为以下几种：</strong></p>
<ul>
<li>r：代表权限是可读，r也可以用数字4表示</li>
<li>w：代表权限是可写，w也可以用数字2表示</li>
<li>x：代表权限是可执行，x也可以用数字1表示</li>
</ul>
<p><strong>文件和目录权限的区别：</strong></p>
<p> 对文件和目录而言，读写执行表示不同的意义。</p>
<p> 对于文件：</p>
<table>
<thead>
<tr>
<th style="text-align:left">权限名称</th>
<th style="text-align:right">可执行操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">r</td>
<td style="text-align:right">可以使用cat查看文件的内容</td>
</tr>
<tr>
<td style="text-align:left">w</td>
<td style="text-align:right">可以修改文件的内容</td>
</tr>
<tr>
<td style="text-align:left">x</td>
<td style="text-align:right">可以将其运行为二进制文件</td>
</tr>
</tbody>
</table>
<p> 对于目录：</p>
<table>
<thead>
<tr>
<th style="text-align:left">权限名称</th>
<th style="text-align:right">可执行操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">r</td>
<td style="text-align:right">可以查看目录下列表</td>
</tr>
<tr>
<td style="text-align:left">w</td>
<td style="text-align:right">可以创建和删除目录下文件</td>
</tr>
<tr>
<td style="text-align:left">x</td>
<td style="text-align:right">可以使用cd进入目录</td>
</tr>
</tbody>
</table>
<p><strong>在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。</strong></p>
<ul>
<li><p><strong>所有者</strong></p>
<p>一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用ls ‐ahl命令可以看到文件的所有者 也可以使用chown 用户名  文件名来修改文件的所有者 。</p>
</li>
<li><p><strong>文件所在组</strong></p>
<p>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组 用ls ‐ahl命令可以看到文件的所有组 也可以使用chgrp  组名  文件名来修改文件所在的组。 </p>
</li>
<li><p><strong>其它组</strong></p>
<p>除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组 </p>
</li>
</ul>
<blockquote>
<p>我们再来看看如何修改文件/目录的权限。</p>
</blockquote>
<p><strong>修改文件/目录的权限的命令：<code>chmod</code></strong></p>
<p>示例：修改/test下的aaa.txt的权限为属主有全部权限，属主所在的组有读写权限，<br>其他用户只有读的权限</p>
<p><strong><code>chmod u=rwx,g=rw,o=r aaa.txt</code></strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/5/164697447dc6ecac?w=525&amp;h=246&amp;f=png&amp;s=12362" alt=""></p>
<p>上述示例还可以使用数字表示：</p>
<p>chmod 764 aaa.txt</p>
<p><strong>补充一个比较常用的东西:</strong></p>
<p>假如我们装了一个zookeeper，我们每次开机到要求其自动启动该怎么办？</p>
<ol>
<li>新建一个脚本zookeeper</li>
<li>为新建的脚本zookeeper添加可执行权限，命令是:<code>chmod +x zookeeper</code></li>
<li>把zookeeper这个脚本添加到开机启动项里面，命令是：<code>chkconfig --add  zookeeper</code></li>
<li>如果想看看是否添加成功，命令是：<code>chkconfig --list</code></li>
</ol>
<h3 id="4-6-Linux-用户管理"><a href="#4-6-Linux-用户管理" class="headerlink" title="4.6 Linux 用户管理"></a>4.6 Linux 用户管理</h3><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p><strong>Linux用户管理相关命令:</strong></p>
<ul>
<li><code>useradd 选项 用户名</code>:添加用户账号</li>
<li><code>userdel 选项 用户名</code>:删除用户帐号</li>
<li><code>usermod 选项 用户名</code>:修改帐号</li>
<li><code>passwd 用户名</code>:更改或创建用户的密码</li>
<li><code>passwd -S 用户名</code> :显示用户账号密码信息</li>
<li><code>passwd -d 用户名</code>:  清除用户密码</li>
</ul>
<p>useradd命令用于Linux中创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。</p>
<p>passwd命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p>
<h3 id="4-7-Linux系统用户组的管理"><a href="#4-7-Linux系统用户组的管理" class="headerlink" title="4.7 Linux系统用户组的管理"></a>4.7 Linux系统用户组的管理</h3><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p>
<p><strong>Linux系统用户组的管理相关命令:</strong></p>
<ul>
<li><code>groupadd 选项 用户组</code> :增加一个新的用户组</li>
<li><code>groupdel 用户组</code>:要删除一个已有的用户组</li>
<li><code>groupmod 选项 用户组</code> : 修改用户组的属性</li>
</ul>
<h3 id="4-8-其他常用命令"><a href="#4-8-其他常用命令" class="headerlink" title="4.8 其他常用命令"></a>4.8 其他常用命令</h3><ul>
<li><strong><code>pwd</code>：</strong> 显示当前所在位置</li>
<li><strong><code>grep 要搜索的字符串 要搜索的文件 --color</code>：</strong> 搜索命令，–color代表高亮显示</li>
<li><p><strong><code>ps -ef</code>/<code>ps aux</code>：</strong> 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<strong><code>ps aux|grep redis</code></strong> （查看包括redis字符串的进程）</p>
<p>注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。</p>
</li>
<li><p><strong><code>kill -9 进程的pid</code>：</strong> 杀死进程（-9 表示强制终止。）</p>
<p>先用ps查找进程，然后用kill杀掉</p>
</li>
<li><strong>网络通信命令：</strong><ul>
<li>查看当前系统的网卡信息：ifconfig</li>
<li>查看与某台机器的连接情况：ping </li>
<li>查看当前系统的端口使用：netstat -an</li>
</ul>
</li>
<li><strong><code>shutdown</code>：</strong>  <code>shutdown -h now</code>： 指定现在立即关机；<code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code>:指定5分钟后关机，同时送出警告信息给登入用户。</li>
<li><strong><code>reboot</code>：</strong>  <strong><code>reboot</code>：</strong>  重开机。<strong><code>reboot -w</code>：</strong> 做个重开机的模拟（只有纪录并不会真的重开机）。</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-07-30T03:02:35.767Z"><a href="/2018/07/30/Java相关/Java基础知识面试题总结/超详细的Java面试题总结（四 ）之JavaWeb基础知识总结/">2018-07-30</a></time>
      
      
  
    <h1 class="title"><a href="/2018/07/30/Java相关/Java基础知识面试题总结/超详细的Java面试题总结（四 ）之JavaWeb基础知识总结/"></a></h1>
  

    </header>
    <div class="entry">
      
        <p>下面的都是自己之前在学习JavaWeb的时候总结的，对于巩固JavaWeb的基础知识应该有很大帮助。后面还会把框架的面试题总结一下。</p>
<h2 id="Servlet总结："><a href="#Servlet总结：" class="headerlink" title="Servlet总结："></a><font face="楷体">Servlet总结</font>：</h2><p>在Java Web程序中，<strong>Servlet</strong>主要负责接收用户请求<strong>HttpServletRequest</strong>,在<strong>doGet()</strong>,<strong>doPost()</strong>中做相应的处理，并将回应<strong>HttpServletResponse</strong>反馈给用户。Servlet可以设置初始化参数，供Servlet内部使用。一个Servlet类只会有一个实例，在它初始化时调用<strong>init()方法</strong>，销毁时调用<strong>destroy()方法</strong>。<strong>Servlet需要在web.xml中配置</strong>（MyEclipse中创建Servlet会自动配置），<strong>一个Servlet可以设置多个URL访问</strong>。<strong>Servlet不是线程安全</strong>，因此要谨慎使用类变量。</p>
<h2 id="阐述Servlet和CGI的区别"><a href="#阐述Servlet和CGI的区别" class="headerlink" title="阐述Servlet和CGI的区别?"></a><font face="楷体">阐述Servlet和CGI的区别?</font></h2><p><strong>CGI的不足之处：</strong></p>
<p>1，需要为每个请求启动一个操作CGI程序的系统进程。如果请求频繁，这将会带来很大的开销。</p>
<p>2，需要为每个请求加载和运行一个CGI程序，这将带来很大的开销 </p>
<p>3，需要重复编写处理网络协议的代码以及编码，这些工作都是非常耗时的。</p>
<p><strong>Servlet的优点：</strong></p>
<p>1，只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销</p>
<p>2，如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销</p>
<p>3，所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。</p>
<p>4，Servlet能直接和Web服务器交互，而普通的CGI程序不能。Servlet还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。</p>
<p>补充：Sun Microsystems公司在1996年发布Servlet技术就是为了和CGI进行竞争，Servlet是一个特殊的Java程序，一个基于Java的Web应用通常包含一个或多个Servlet类。Servlet不能够自行创建并执行，它是在Servlet容器中运行的，容器将用户的请求传递给Servlet程序，并将Servlet的响应回传给用户。通常一个Servlet会关联一个或多个JSP页面。以前CGI经常因为性能开销上的问题被诟病，然而Fast CGI早就已经解决了CGI效率上的问题，所以面试的时候大可不必信口开河的诟病CGI，事实上有很多你熟悉的网站都使用了CGI技术。</p>
<p>参考：《javaweb整合开发王者归来》P7</p>
<h2 id="Servlet接口中有哪些方法及Servlet生命周期探秘"><a href="#Servlet接口中有哪些方法及Servlet生命周期探秘" class="headerlink" title="Servlet接口中有哪些方法及Servlet生命周期探秘"></a><font face="楷体">Servlet接口中有哪些方法及Servlet生命周期探秘</font></h2><p>Servlet接口定义了5个方法，其中<strong>前三个方法与Servlet生命周期相关</strong>：</p>
<ul>
<li><strong>void init(ServletConfig config) throws ServletException</strong></li>
<li><strong>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</strong></li>
<li><strong>void destory()</strong></li>
<li>java.lang.String getServletInfo()</li>
<li>ServletConfig getServletConfig()</li>
</ul>
<p><strong>生命周期：</strong> <strong>Web容器加载Servlet并将其实例化后，Servlet生命周期开始</strong>，容器运行其<strong>init()方法</strong>进行Servlet的初始化；请求到达时调用Servlet的<strong>service()方法</strong>，service()方法会根据需要调用与请求对应的<strong>doGet或doPost</strong>等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<strong>destroy()方法</strong>。<strong>init方法和destory方法只会执行一次，service方法客户端每次请求Servlet都会执行</strong>。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p>
<p>参考：《javaweb整合开发王者归来》P81</p>
<h2 id="get和post请求的区别？"><a href="#get和post请求的区别？" class="headerlink" title="get和post请求的区别？"></a><font face="楷体">get和post请求的区别？</font></h2><p>①get请求用来从服务器上获得资源，而post是用来向服务器提交数据；</p>
<p>②get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL；</p>
<p>③get传输的数据要受到URL长度限制（1024字节即256个字符）；而post可以传输大量的数据，上传文件通常要使用post方式；</p>
<p>④使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；</p>
<p>⑤get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是”%20”。</p>
<p>补充：GET方式提交表单的典型应用是搜索引擎。GET方式就是被设计为查询用的。</p>
<h2 id="什么情况下调用doGet-和doPost"><a href="#什么情况下调用doGet-和doPost" class="headerlink" title="什么情况下调用doGet()和doPost()?"></a><font face="楷体">什么情况下调用doGet()和doPost()?</font></h2><p>Form标签里的method的属性为get时调用doGet()，为post时调用doPost()。</p>
<h2 id="转发（Forward）和重定向（Redirect）的区别？"><a href="#转发（Forward）和重定向（Redirect）的区别？" class="headerlink" title="转发（Forward）和重定向（Redirect）的区别？"></a><font face="楷体">转发（Forward）和重定向（Redirect）的区别？</font></h2><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p>
<p><strong>转发（Forword）</strong><br>通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">"login_success.jsp"</span>).forward(request, response);</span><br></pre></td></tr></table></figure></p>
<p><strong>重定向（Redirect）</strong> 是利用服务器返回的状态吗来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过HttpServletRequestResponse的setStatus(int status)方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。 </p>
<ol>
<li><strong>从地址栏显示来说</strong></li>
</ol>
<p>forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.<br>redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</p>
<ol>
<li><strong>从数据共享来说</strong></li>
</ol>
<p>forward:转发页面和转发到的页面可以共享request里面的数据.<br>redirect:不能共享数据.</p>
<ol>
<li><strong>从运用地方来说</strong></li>
</ol>
<p>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.<br>redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</p>
<ol>
<li>从效率来说</li>
</ol>
<p>forward:高.<br>redirect:低.</p>
<h2 id="自动刷新（Refresh）"><a href="#自动刷新（Refresh）" class="headerlink" title="自动刷新（Refresh）"></a><font face="楷体">自动刷新（Refresh）</font></h2><p>自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet中通过HttpServletResponse对象设置Header属性实现自动刷新例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response.setHeader(<span class="string">"Refresh"</span>,<span class="string">"1000;URL=http://localhost:8080/servlet/example.htm"</span>);</span><br></pre></td></tr></table></figure></p>
<p>其中1000为时间，单位为毫秒。URL指定就是要跳转的页面（如果设置自己的路径，就会实现没过一秒自动刷新本页面一次）</p>
<h2 id="Servlet与线程安全"><a href="#Servlet与线程安全" class="headerlink" title="Servlet与线程安全"></a><font face="楷体">Servlet与线程安全</font></h2><p><strong>Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。</strong> 解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。<br>注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。</p>
<p>参考：《javaweb整合开发王者归来》P92</p>
<h2 id="JSP和Servlet是什么关系？"><a href="#JSP和Servlet是什么关系？" class="headerlink" title="JSP和Servlet是什么关系？"></a><font face="楷体">JSP和Servlet是什么关系？</font></h2><p>其实这个问题在上面已经阐述过了，Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。</p>
<h2 id="JSP工作原理："><a href="#JSP工作原理：" class="headerlink" title="JSP工作原理："></a><font face="楷体">JSP工作原理：</font></h2><p>JSP是一种Servlet，但是与HttpServlet的工作方式不太一样。HttpServlet是先由源代码编译为class文件后部署到服务器下，为先编译后部署。而JSP则是先部署后编译。JSP会在客户端第一次请求JSP文件时被编译为HttpJspPage类（接口Servlet的一个子类）。该类会被服务器临时存放在服务器工作目录里面。下面通过实例给大家介绍。<br>工程JspLoginDemo下有一个名为login.jsp的Jsp文件，把工程第一次部署到服务器上后访问这个Jsp文件，我们发现这个目录下多了下图这两个东东。<br>.class文件便是JSP对应的Servlet。编译完毕后再运行class文件来响应客户端请求。以后客户端访问login.jsp的时候，Tomcat将不再重新编译JSP文件，而是直接调用class文件来响应客户端请求。<br><img src="https://user-gold-cdn.xitu.io/2018/3/31/1627bee073079a28?w=675&amp;h=292&amp;f=jpeg&amp;s=133553" alt="JSP工作原理"><br>由于JSP只会在客户端第一次请求的时候被编译 ，因此第一次请求JSP时会感觉比较慢，之后就会感觉快很多。如果把服务器保存的class文件删除，服务器也会重新编译JSP。</p>
<p>开发Web程序时经常需要修改JSP。Tomcat能够自动检测到JSP程序的改动。如果检测到JSP源代码发生了改动。Tomcat会在下次客户端请求JSP时重新编译JSP，而不需要重启Tomcat。这种自动检测功能是默认开启的，检测改动会消耗少量的时间，在部署Web应用的时候可以在web.xml中将它关掉。</p>
<p>参考：《javaweb整合开发王者归来》P97</p>
<h2 id="JSP有哪些内置对象？作用分别是什么？"><a href="#JSP有哪些内置对象？作用分别是什么？" class="headerlink" title="JSP有哪些内置对象？作用分别是什么？"></a><font face="楷体">JSP有哪些内置对象？作用分别是什么？</font></h2><p><a href="http://blog.csdn.net/qq_34337272/article/details/64310849" target="_blank" rel="noopener">JSP内置对象 - CSDN博客 </a> </p>
<p>JSP有9个内置对象：</p>
<ul>
<li>request：封装客户端的请求，其中包含来自GET或POST请求的参数；</li>
<li>response：封装服务器对客户端的响应；</li>
<li>pageContext：通过该对象可以获取其他对象；</li>
<li>session：封装用户会话的对象；</li>
<li>application：封装服务器运行环境的对象；</li>
<li>out：输出服务器响应的输出流对象；</li>
<li>config：Web应用的配置对象；</li>
<li>page：JSP页面本身（相当于Java程序中的this）；</li>
<li>exception：封装页面抛出异常的对象。</li>
</ul>
<h2 id="Request对象的主要方法有哪些？"><a href="#Request对象的主要方法有哪些？" class="headerlink" title="Request对象的主要方法有哪些？"></a><font face="楷体">Request对象的主要方法有哪些？</font></h2><ul>
<li>setAttribute(String name,Object)：设置名字为name的request 的参数值 </li>
<li>getAttribute(String name)：返回由name指定的属性值 </li>
<li>getAttributeNames()：返回request 对象所有属性的名字集合，结果是一个枚举的实例 </li>
<li>getCookies()：返回客户端的所有 Cookie 对象，结果是一个Cookie 数组 </li>
<li>getCharacterEncoding() ：返回请求中的字符编码方式 = getContentLength() ：返回请求的 Body的长度 </li>
<li>getHeader(String name) ：获得HTTP协议定义的文件头信息 </li>
<li>getHeaders(String name) ：返回指定名字的request Header 的所有值，结果是一个枚举的实例 </li>
<li>getHeaderNames() ：返回所以request Header 的名字，结果是一个枚举的实例 </li>
<li>getInputStream() ：返回请求的输入流，用于获得请求中的数据 </li>
<li>getMethod() ：获得客户端向服务器端传送数据的方法 </li>
<li>getParameter(String name) ：获得客户端传送给服务器端的有 name指定的参数值 </li>
<li>getParameterNames() ：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例 </li>
<li>getParameterValues(String name)：获得有name指定的参数的所有值 </li>
<li>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称 </li>
<li>getQueryString() ：获得查询字符串 </li>
<li>getRequestURI() ：获取发出请求字符串的客户端地址 </li>
<li>getRemoteAddr()：获取客户端的 IP 地址 </li>
<li>getRemoteHost() ：获取客户端的名字 </li>
<li>getSession([Boolean create]) ：返回和请求相关 Session </li>
<li>getServerName() ：获取服务器的名字 </li>
<li>getServletPath()：获取客户端所请求的脚本文件的路径 </li>
<li>getServerPort()：获取服务器的端口号 </li>
<li>removeAttribute(String name)：删除请求中的一个属性 </li>
</ul>
<h2 id="request-getAttribute-和-request-getParameter-有何区别"><a href="#request-getAttribute-和-request-getParameter-有何区别" class="headerlink" title="request.getAttribute()和 request.getParameter()有何区别?"></a><font face="楷体">request.getAttribute()和 request.getParameter()有何区别?</font></h2><p><strong>从获取方向来看：</strong></p>
<p>getParameter()是获取 POST/GET 传递的参数值；</p>
<p>getAttribute()是获取对象容器中的数据值；</p>
<p><strong>从用途来看：</strong></p>
<p>getParameter用于客户端重定向时，即点击了链接或提交按扭时传值用，即用于在用表单或url重定向传值时接收数据用。</p>
<p>getAttribute用于服务器端重定向时，即在 sevlet 中使用了 forward 函数,或 struts 中使用了<br>mapping.findForward。 getAttribute 只能收到程序用 setAttribute 传过来的值。</p>
<p>另外，可以用 setAttribute,getAttribute 发送接收对象.而 getParameter 显然只能传字符串。<br>setAttribute 是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另一个页面时，应用服务器会把这块内存拷贝另一个页面所对应的内存中。这样getAttribute就能取得你所设下的值，当然这种方法可以传对象。session也一样，只是对象在内存中的生命周期不一样而已。getParameter只是应用服务器在分析你送上来的 request页面的文本时，取得你设在表单或 url 重定向时的值。</p>
<p><strong>总结：</strong></p>
<p>getParameter 返回的是String,用于读取提交的表单中的值;（获取之后会根据实际需要转换为自己需要的相应类型，比如整型，日期类型啊等等）</p>
<p>getAttribute 返回的是Object，需进行转换,可用setAttribute 设置成任意对象，使用很灵活，可随时用</p>
<h2 id="include指令include的行为的区别"><a href="#include指令include的行为的区别" class="headerlink" title="include指令include的行为的区别"></a><font face="楷体">include指令include的行为的区别</font></h2><p><strong>include指令：</strong> JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。 语法格式如下：<br>&lt;%@ include file=”文件相对 url 地址” %&gt;</p>
<p>i<strong>nclude动作：</strong> <a href="jsp:include" target="_blank" rel="noopener">jsp:include</a>动作元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。语法格式如下：<br>&lt;jsp:include page=”相对 URL 地址” flush=”true” /&gt;</p>
<h2 id="JSP九大内置对象，七大动作，三大指令"><a href="#JSP九大内置对象，七大动作，三大指令" class="headerlink" title="JSP九大内置对象，七大动作，三大指令-"></a><font face="楷体">JSP九大内置对象，七大动作，三大指令-</font></h2><p><a href="http://blog.csdn.net/qq_34337272/article/details/64310849" target="_blank" rel="noopener">JSP九大内置对象，七大动作，三大指令总结</a></p>
<h2 id="讲解JSP中的四种作用域"><a href="#讲解JSP中的四种作用域" class="headerlink" title="讲解JSP中的四种作用域"></a><font face="楷体">讲解JSP中的四种作用域</font></h2><p>JSP中的四种作用域包括page、request、session和application，具体来说：</p>
<ul>
<li><strong>page</strong>代表与一个页面相关的对象和属性。</li>
<li><strong>request</strong>代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。</li>
<li><strong>session</strong>代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。</li>
<li><strong>application</strong>代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</li>
</ul>
<h2 id="如何实现JSP或Servlet的单线程模式？"><a href="#如何实现JSP或Servlet的单线程模式？" class="headerlink" title="如何实现JSP或Servlet的单线程模式？"></a><font face="楷体">如何实现JSP或Servlet的单线程模式？</font></h2><p>对于JSP页面，可以通过page指令进行设置。<br>&lt;%@page isThreadSafe=”false”%&gt;</p>
<p>对于Servlet，可以让自定义的Servlet实现SingleThreadModel标识接口。</p>
<p>说明：如果将JSP或Servlet设置成单线程工作模式，会导致每个请求创建一个Servlet实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。</p>
<h2 id="实现会话跟踪的技术有哪些？"><a href="#实现会话跟踪的技术有哪些？" class="headerlink" title="实现会话跟踪的技术有哪些？"></a><font face="楷体">实现会话跟踪的技术有哪些？</font></h2><ol>
<li><strong>使用Cookie</strong></li>
</ol>
<p>向客户端发送Cookie<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie c =<span class="keyword">new</span> Cookie(<span class="string">"name"</span>,<span class="string">"value"</span>); <span class="comment">//创建Cookie </span></span><br><span class="line">c.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>); <span class="comment">//设置最大时效，此处设置的最大时效为一天</span></span><br><span class="line">response.addCookie(c); <span class="comment">//把Cookie放入到HTTP响应中</span></span><br></pre></td></tr></table></figure></p>
<p>从客户端读取Cookie<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String name =<span class="string">"name"</span>; </span><br><span class="line">Cookie[]cookies =request.getCookies(); </span><br><span class="line"><span class="keyword">if</span>(cookies !=<span class="keyword">null</span>)&#123; </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;cookies.length;i++)&#123; </span><br><span class="line">    Cookie cookie =cookies[i]; </span><br><span class="line">    <span class="keyword">if</span>(name.equals(cookis.getName())) </span><br><span class="line">    <span class="comment">//something is here. </span></span><br><span class="line">    <span class="comment">//you can get the value </span></span><br><span class="line">    cookie.getValue(); </span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>优点:</strong> 数据可以持久保存，不需要服务器资源，简单，基于文本的Key-Value</p>
<p><strong>缺点:</strong> 大小受到限制，用户可以禁用Cookie功能，由于保存在本地，有一定的安全风险。</p>
<ol>
<li>URL 重写</li>
</ol>
<p>在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。 </p>
<p><strong>优点：</strong> 在Cookie被禁用的时候依然可以使用</p>
<p><strong>缺点：</strong> 必须对网站的URL进行编码，所有页面必须动态生成，不能用预先记录下来的URL进行访问。</p>
<p>3.隐藏的表单域<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span> =<span class="string">"session"</span> <span class="attr">value</span>=<span class="string">"..."</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>优点：</strong> Cookie被禁时可以使用</p>
<p><strong>缺点：</strong> 所有页面必须是表单提交之后的结果。</p>
<ol>
<li>HttpSession</li>
</ol>
<p> 在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方 法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用 HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象。与上面三种方式不同的 是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession 中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了 Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。</p>
<h2 id="Cookie和Session的的区别？"><a href="#Cookie和Session的的区别？" class="headerlink" title="Cookie和Session的的区别？"></a><font face="楷体">Cookie和Session的的区别？</font></h2><ol>
<li>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。</li>
<li>思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。</li>
<li>Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/3/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  
<div class="widget tag">
  <h3 class="title">分类</h3>
    <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">1</span></li></ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo-light/">hexo, light</a><span class="tag-list-count">1</span></li></ul>
</div>


  <div class="widget tag">
<h3 class="title">友情链接</h3>
<ul class="entry">
<li><a href="https://www.baidu.com/" title="百度搜索" target="_blank">百度搜索</a></li>
<li><a href="https://www.github.com/" title="github官网" target="_blank">github官网</a></li>
</ul>
</div>


  <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="https://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=1&ptype=1&speed=0&skin=5&isTitle=1&noborder=1&isWeibo=1&isFans=0&uid=5684095680&verifier=b4735243&dpc=1"></iframe>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2018 happy1st
  
</div>
<div class="clearfix"></div></footer>
  <script src="https://libs.baidu.com/jquery/2.1.1/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

<!--page counter part-->
<script>
function addCount (Counter) {
        url=$('.article-date').attr('href').trim();
        title = $('.article-title').text().trim();
        var query=new AV.Query(Counter);
        //use url as unique idnetfication
        query.equalTo("url",url);
        query.find({
            success: function(results){
                if(results.length>0)
                {
                    var counter=results[0];
                    counter.fetchWhenSave(true); //get recent result
                    counter.increment("time");
                    counter.save();
                }
                else
                {
                    var newcounter=new Counter();
                    newcounter.set("title",title);
                    newcounter.set("url",url);
                    newcounter.set("time",1);
                    newcounter.save(null,{
                        success: function(newcounter){
                        //alert('New object created');
                        },
                        error: function(newcounter,error){
                        alert('Failed to create');
                        }
                        });
                }
            },
            error: function(error){
                //find null is not a error
                alert('Error:'+error.code+" "+error.message);
            }
        });
}
$(function(){
        var Counter=AV.Object.extend("Counter");
        //only increse visit counting when intering a page
        if ($('.article-title').length == 1)
           addCount(Counter);
        var query=new AV.Query(Counter);
        query.descending("time");
        // the sum of popular posts
        query.limit(10); 
        query.find({
            success: function(results){
                    for(var i=0;i<results.length;i++)    
                    {
                        var counter=results[i];
                        title=counter.get("title");
                        url=counter.get("url");
                        time=counter.get("time");
                        // add to the popularlist widget
                        showcontent=title+" ("+time+")";
                        //notice the "" in href
                        $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                    }
                },
            error: function(error){
                alert("Error:"+error.code+" "+error.message);
            }
            }
        )
        });
</script>
</body>
</html>

